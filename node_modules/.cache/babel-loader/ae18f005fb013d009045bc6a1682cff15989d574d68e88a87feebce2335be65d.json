{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDirection = exports[\"default\"] = exports.Spotlight = void 0;\nvar _keymap = require(\"@enact/core/keymap\");\nvar _snapshot = require(\"@enact/core/snapshot\");\nvar _platform = _interopRequireDefault(require(\"@enact/core/platform\"));\nvar _last = _interopRequireDefault(require(\"ramda/src/last\"));\nvar _Accelerator = _interopRequireDefault(require(\"../Accelerator\"));\nvar _Spottable = require(\"../Spottable\");\nvar _Pause = require(\"../Pause\");\nvar _inputType = require(\"./inputType\");\nvar _utils = require(\"./utils\");\nvar _container = require(\"./container\");\nvar _pointer = require(\"./pointer\");\nvar _target = require(\"./target\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n/*\n * A javascript-based implementation of Spatial Navigation.\n *\n * Copyright (c) 2016 Luke Chang.\n * https://github.com/luke-chang/js-spatial-navigation\n *\n * Licensed under the MPL license.\n */\n\n/**\n * Exports the {@link spotlight.Spotlight} object used for controlling spotlight behavior and the\n * {@link spotlight.Spotlight.getDirection} function for mapping a keycode to a spotlight direction.\n *\n * The default export is {@link spotlight.Spotlight}.\n *\n * @module spotlight\n * @exports default Spotlight\n * @exports getDirection\n */\n\nvar isDown = (0, _keymap.is)('down');\nvar isEnter = (0, _keymap.is)('enter');\nvar isLeft = (0, _keymap.is)('left');\nvar isRight = (0, _keymap.is)('right');\nvar isUp = (0, _keymap.is)('up');\n\n/**\n * Translates keyCodes into 5-way direction descriptions (e.g. `'down'`)\n *\n * @function\n * @memberof spotlight\n * @param {Number} keyCode - Key code to analyze\n * @returns {String|false} - One of `'up'`, `'down'`, `'left'`, `'right'` or `false` if not a direction key\n * @public\n */\nvar getDirection = function getDirection(keyCode) {\n  return isDown(keyCode) && 'down' || isLeft(keyCode) && 'left' || isRight(keyCode) && 'right' || isUp(keyCode) && 'up';\n};\nexports.getDirection = getDirection;\nvar SpotlightAccelerator = new _Accelerator[\"default\"]();\n\n/**\n * Provides 5-way navigation and focus support\n *\n * ```\n * import Spotlight from '@enact/Spotlight';\n *\n * // get the currently focused component\n * const current = Spotlight.getCurrent();\n *\n * // focus an element by CSS selector\n * Spotlight.focus('.my-custom-class');\n *\n * // is `current` focusable?\n * const isFocused = Spotlight.isSpottable(current);\n * ```\n *\n * @type {Object}\n * @memberof spotlight\n * @public\n */\nvar Spotlight = function () {\n  'use strict';\n\n  /*\n  /* private vars\n  */\n  var _initialized = false;\n  var _duringFocusChange = false;\n  var _focusRingElement = null;\n\n  /*\n   * Whether a 5-way directional key is being held.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  var _5WayKeyHold = false;\n\n  /*\n   * Whether to set focus during the next window focus event\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  var _spotOnWindowFocus = false;\n\n  /*\n   * `true` when a pointer move event occurs during a keypress. Used to short circuit key down\n   * handling until the next keyup occurs.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  var _pointerMoveDuringKeyPress = false;\n\n  /*\n  * protected methods\n  */\n\n  function preventDefault(evt) {\n    evt.preventDefault();\n    evt.stopPropagation();\n    return false;\n  }\n  function shouldPreventNavigation() {\n    return (0, _Pause.isPaused)() || (0, _container.getAllContainerIds)().length === 0;\n  }\n  function _getCurrent() {\n    if (!(0, _snapshot.isWindowReady)()) return;\n    var activeElement = document.activeElement;\n    if (activeElement && activeElement !== document.body) {\n      return activeElement;\n    }\n  }\n\n  // An extension point for updating pointer mode based on the current platform.\n  // Currently only webOS\n  function setPlatformPointerMode() {\n    var palmSystem = window.PalmSystem;\n    if (palmSystem && palmSystem.cursor) {\n      (0, _pointer.setPointerMode)(palmSystem.cursor.visibility);\n    }\n  }\n  function focusElement(elem, containerIds, fromPointer) {\n    var _window$PalmSystem$cu;\n    if (!elem) {\n      return false;\n    }\n    if ((0, _pointer.getPointerMode)() && !fromPointer && ((0, _inputType.getInputType)() === 'touch' || typeof window !== 'undefined' && (!window.PalmSystem || (_window$PalmSystem$cu = window.PalmSystem.cursor) !== null && _window$PalmSystem$cu !== void 0 && _window$PalmSystem$cu.visibility))) {\n      (0, _container.setContainerLastFocusedElement)(elem, containerIds);\n      return false;\n    }\n    var currentFocusedElement = _getCurrent();\n    if (elem === currentFocusedElement) {\n      return true;\n    }\n    var focusOptions = (0, _container.isWithinOverflowContainer)(elem, containerIds) ? {\n      preventScroll: true\n    } : null;\n    var silentFocus = function silentFocus() {\n      elem.focus(focusOptions);\n      focusChanged(elem, containerIds);\n    };\n    if (_duringFocusChange) {\n      silentFocus();\n      return true;\n    }\n    _duringFocusChange = true;\n    if ((0, _Pause.isPaused)()) {\n      silentFocus();\n      _duringFocusChange = false;\n      return true;\n    }\n    elem.focus(focusOptions);\n\n    /* istanbul ignore next */\n    if (_focusRingElement) {\n      var elemRect = elem.getBoundingClientRect();\n      _focusRingElement.style.left = \"\".concat(elemRect.x + window.scrollX, \"px\");\n      _focusRingElement.style.top = \"\".concat(elemRect.y + window.scrollY, \"px\");\n      _focusRingElement.style.width = \"\".concat(elemRect.width, \"px\");\n      _focusRingElement.style.height = \"\".concat(elemRect.height, \"px\");\n    }\n    _duringFocusChange = false;\n    focusChanged(elem, containerIds);\n    return true;\n  }\n  function focusChanged(elem, containerIds) {\n    if (!containerIds || !containerIds.length) {\n      containerIds = (0, _container.getContainersForNode)(elem);\n    }\n    var containerId = (0, _last[\"default\"])(containerIds);\n    if (containerId) {\n      (0, _container.setContainerLastFocusedElement)(elem, containerIds);\n      (0, _container.setLastContainer)(containerId);\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n      assignFocusPreview(elem);\n    }\n  }\n  function restoreFocus() {\n    var lastContainerId = (0, _container.getLastContainer)();\n    var next;\n    if (lastContainerId) {\n      var position = (0, _pointer.getLastPointerPosition)();\n\n      // walk up the chain of containers from the last to attempt to find a target\n      next = (0, _container.getContainersForNode)((0, _container.getContainerNode)(lastContainerId)).reverse();\n\n      // only prepend last focused if it exists so that Spotlight.focus() doesn't receive\n      // a falsy target\n      var lastFocusedElement = (0, _container.getContainerLastFocusedElement)(lastContainerId);\n      while ((0, _container.isContainer)(lastFocusedElement)) {\n        var _getContainerConfig = (0, _container.getContainerConfig)(lastFocusedElement);\n        lastFocusedElement = _getContainerConfig.lastFocusedElement;\n      }\n      var lastContainerNode = (0, _container.getContainerNode)(lastContainerId);\n      if (!lastFocusedElement || lastContainerNode.getBoundingClientRect && lastFocusedElement.getBoundingClientRect && !(0, _utils.contains)(lastContainerNode.getBoundingClientRect(), lastFocusedElement.getBoundingClientRect())) {\n        lastFocusedElement = (0, _container.getContainerConfig)(lastContainerId).overflow && (0, _target.getNearestTargetFromPosition)(position, lastContainerId);\n      }\n      if (lastFocusedElement) {\n        next.unshift(lastFocusedElement);\n      }\n    } else {\n      next = [_container.rootContainerId];\n    }\n\n    // attempt to find a target starting with the last focused element in the last\n    // container, followed by the last container, and finally the root container\n    return next.reduce(function (focused, target) {\n      return focused || Spotlight.focus(target);\n    }, false);\n  }\n\n  // The below should be gated on non-production environment only.\n  function assignFocusPreview(elem) {\n    var directions = ['up', 'right', 'down', 'left'],\n      nextClassBase = _Spottable.spottableClass + '-next-';\n\n    // Remove all previous targets\n    directions.forEach(function (dir) {\n      var nextClass = nextClassBase + dir,\n        prevElems = (0, _utils.parseSelector)('.' + nextClass);\n      if (prevElems && prevElems.length !== 0) {\n        prevElems.forEach(function (prevElem) {\n          return prevElem.classList.remove(nextClass);\n        });\n      }\n    });\n\n    // Find all next targets and identify them\n    directions.forEach(function (dir) {\n      var nextElem = (0, _target.getTargetByDirectionFromElement)(dir, elem);\n      if (nextElem) {\n        nextElem.classList.add(nextClassBase + dir);\n      }\n    });\n  }\n  function spotNextFromPoint(direction, position) {\n    var containerId = Spotlight.getActiveContainer();\n    var next = (0, _target.getTargetByDirectionFromPosition)(direction, position, containerId);\n    if (next) {\n      (0, _container.setContainerPreviousTarget)(containerId, direction, next, (0, _container.getContainerLastFocusedElement)(containerId));\n      return focusElement(next, (0, _container.getContainersForNode)(next));\n    }\n    return false;\n  }\n  function spotNext(direction, currentFocusedElement, currentContainerIds) {\n    var next = (0, _target.getTargetByDirectionFromElement)(direction, currentFocusedElement);\n    if (next) {\n      var currentContainerId = (0, _last[\"default\"])(currentContainerIds);\n      var nextContainerIds = (0, _container.getContainersForNode)(next);\n\n      // prevent focus if 5-way is being held and the next element isn't wrapped by\n      // the current element's immediate container\n      if (_5WayKeyHold && nextContainerIds.indexOf(currentContainerId) < 0 && !(0, _container.isContainer5WayHoldable)(currentContainerId)) {\n        return false;\n      }\n      (0, _container.notifyLeaveContainer)(direction, currentFocusedElement, currentContainerIds, next, nextContainerIds);\n      (0, _container.setContainerPreviousTarget)(currentContainerId, direction, next, currentFocusedElement);\n      var focused = focusElement(next, nextContainerIds);\n      (0, _container.notifyEnterContainer)(direction, currentFocusedElement, currentContainerIds, next, nextContainerIds);\n      return focused;\n    }\n    (0, _container.notifyLeaveContainerFail)(direction, currentFocusedElement, currentContainerIds);\n    return false;\n  }\n  function onAcceleratedKeyDown(evt) {\n    var direction = getDirection(evt.keyCode);\n    if (!direction) return;\n    var currentFocusedElement = _getCurrent();\n    var currentContainerIds = (0, _container.getContainersForNode)(currentFocusedElement);\n    spotNext(direction, currentFocusedElement, currentContainerIds);\n  }\n  function onBlur() {\n    var current = _getCurrent();\n    if (current) {\n      current.blur();\n    }\n    Spotlight.setPointerMode(false);\n    _spotOnWindowFocus = true;\n    _pointerMoveDuringKeyPress = false;\n  }\n  function handleWebOSMouseEvent(ev) {\n    if (!(0, _Pause.isPaused)() && ev && ev.detail && ev.detail.type === 'Leave') {\n      onBlur();\n    }\n  }\n  function handleKeyboardStateChangeEvent(_ref) {\n    var visibility = _ref.visibility;\n    if (!visibility) {\n      setPlatformPointerMode();\n    }\n  }\n  function onFocus() {\n    // Normally, there isn't focus here unless the window has been blurred above. On webOS, the\n    // platform may focus the window after the app has already focused a component so we prevent\n    // trying to focus something else (potentially) unless the window was previously blurred\n    if (_spotOnWindowFocus) {\n      setPlatformPointerMode();\n\n      // If the window was previously blurred while in pointer mode, the last active containerId may\n      // not have yet set focus to its spottable elements. For this reason we can't rely on setting focus\n      // to the last focused element of the last active containerId, so we use rootContainerId instead\n      var lastFocusedElement = (0, _container.getContainerLastFocusedElement)(_container.rootContainerId);\n      while ((0, _container.isContainer)(lastFocusedElement)) {\n        var _getContainerConfig2 = (0, _container.getContainerConfig)(lastFocusedElement);\n        lastFocusedElement = _getContainerConfig2.lastFocusedElement;\n      }\n      if (!Spotlight.focus(lastFocusedElement)) {\n        // If the last focused element was previously also disabled (or no longer exists), we\n        // need to set focus somewhere\n        Spotlight.focus();\n      }\n      _spotOnWindowFocus = false;\n    }\n  }\n  function onKeyUp(evt) {\n    _pointerMoveDuringKeyPress = false;\n    var keyCode = evt.keyCode;\n    if (getDirection(keyCode) || isEnter(keyCode)) {\n      SpotlightAccelerator.reset();\n      _5WayKeyHold = false;\n    }\n  }\n  function handlePointerHide() {\n    if (!_getCurrent()) {\n      restoreFocus();\n    }\n  }\n  function onKeyDown(evt) {\n    if (shouldPreventNavigation()) {\n      (0, _pointer.notifyKeyDown)(evt.keyCode);\n      return;\n    }\n    var keyCode = evt.keyCode;\n    var direction = getDirection(keyCode);\n    var pointerHandled = (0, _pointer.notifyKeyDown)(keyCode, handlePointerHide);\n    if (pointerHandled || !(direction || isEnter(keyCode))) {\n      return;\n    }\n    if (!(0, _Pause.isPaused)() && !_pointerMoveDuringKeyPress) {\n      if (_getCurrent()) {\n        SpotlightAccelerator.processKey(evt, onAcceleratedKeyDown);\n      } else if (!spotNextFromPoint(direction, (0, _pointer.getLastPointerPosition)())) {\n        restoreFocus();\n      }\n      _5WayKeyHold = true;\n    }\n    if (direction) {\n      preventDefault(evt);\n    }\n  }\n  function onMouseMove(_ref2) {\n    var target = _ref2.target,\n      clientX = _ref2.clientX,\n      clientY = _ref2.clientY;\n    if (shouldPreventNavigation()) {\n      (0, _pointer.notifyPointerMove)(null, target, clientX, clientY);\n      return;\n    }\n    var current = _getCurrent();\n    var update = (0, _pointer.notifyPointerMove)(current, target, clientX, clientY);\n    if (update) {\n      if (_5WayKeyHold) {\n        _pointerMoveDuringKeyPress = true;\n      }\n      var next = (0, _target.getNavigableTarget)(target);\n\n      // TODO: Consider encapsulating this work within focusElement\n      if (next !== current) {\n        if (next) {\n          focusElement(next, (0, _container.getContainersForNode)(next), true);\n          return true;\n        } else if (current) {\n          current.blur();\n          (0, _container.setLastContainerFromTarget)(current, target);\n        }\n      }\n    }\n  }\n  function onMouseOver(evt) {\n    if (shouldPreventNavigation()) return;\n    var target = evt.target;\n    if ((0, _pointer.getPointerMode)() && (0, _pointer.hasPointerMoved)(evt.clientX, evt.clientY)) {\n      var next = (0, _target.getNavigableTarget)(target); // account for child controls\n\n      if (next && next !== _getCurrent()) {\n        focusElement(next, (0, _container.getContainersForNode)(next), true);\n        return true;\n      }\n      preventDefault(evt);\n    }\n  }\n  function onTouchEnd(evt) {\n    var current = _getCurrent();\n    if (current && !current.contains(evt.target)) {\n      current.blur();\n    }\n  }\n\n  /*\n   * public methods\n   */\n  var exports = /** @lends spotlight.Spotlight */{\n    // eslint-disable-line no-shadow\n    /**\n     * Initializes Spotlight. This is generally handled by\n     * {@link spotlight/SpotlightRootDecorator.SpotlightRootDecorator}.\n     *\n     * @param {Object} containerDefaults Default configuration for new spotlight containers\n     * @returns {undefined}\n     * @public\n     */\n    initialize: function initialize(containerDefaults) {\n      if (!_initialized) {\n        var _getContainerConfig3;\n        window.addEventListener('blur', onBlur);\n        window.addEventListener('focus', onFocus);\n        window.addEventListener('keydown', onKeyDown);\n        window.addEventListener('keyup', onKeyUp);\n        window.addEventListener('mouseover', onMouseOver);\n        window.addEventListener('mousemove', onMouseMove);\n        if (_platform[\"default\"].touch) {\n          window.addEventListener('touchend', onTouchEnd);\n        }\n        if (_platform[\"default\"].webos) {\n          window.top.document.addEventListener('webOSMouse', handleWebOSMouseEvent);\n          window.top.document.addEventListener('keyboardStateChange', handleKeyboardStateChangeEvent);\n        }\n        (0, _container.setLastContainer)(_container.rootContainerId);\n        (0, _container.configureDefaults)(containerDefaults);\n        (0, _container.configureContainer)(_container.rootContainerId);\n        // by default, pointer mode is off but the platform's current state will override that\n        (0, _pointer.setPointerMode)(false);\n        setPlatformPointerMode();\n\n        /* istanbul ignore next */\n        if ((_getContainerConfig3 = (0, _container.getContainerConfig)('spotlightRootDecorator')) !== null && _getContainerConfig3 !== void 0 && _getContainerConfig3.isStandardFocusableMode) {\n          _focusRingElement = document.querySelector('#spotlightFocusRing');\n        }\n        _initialized = true;\n      }\n    },\n    /**\n     * Terminates Spotlight. This is generally handled by {@link spotlight.SpotlightRootDecorator}.\n     *\n     * @public\n     */\n    terminate: function terminate() {\n      window.removeEventListener('blur', onBlur);\n      window.removeEventListener('focus', onFocus);\n      window.removeEventListener('keydown', onKeyDown);\n      window.removeEventListener('keyup', onKeyUp);\n      window.removeEventListener('mouseover', onMouseOver);\n      window.removeEventListener('mousemove', onMouseMove);\n      if (_platform[\"default\"].touch) {\n        window.removeEventListener('touchend', onTouchEnd);\n      }\n      if (_platform[\"default\"].webos) {\n        window.top.document.removeEventListener('webOSMouse', handleWebOSMouseEvent);\n        window.top.document.removeEventListener('keyboardStateChange', handleKeyboardStateChangeEvent);\n      }\n      Spotlight.clear();\n      _initialized = false;\n    },\n    /**\n     * Resets spotlight container information\n     *\n     * @private\n     */\n    clear: function clear() {\n      (0, _container.removeAllContainers)();\n      (0, _container.setDefaultContainer)();\n      (0, _container.setLastContainer)();\n      _duringFocusChange = false;\n    },\n    // set(<config>);\n    // set(<containerId>, <config>);\n    /**\n     * Sets the config for spotlight or the specified containerID\n     *\n     * @function\n     * @param {String|Object} containerIdOrConfig  Configuration object or container ID\n     * @param {Object}        [config]             Configuration object if container ID supplied\n     *                                             in `containerIdOrConfig`\n     * @returns {undefined}\n     * @public\n     */\n    set: _container.configureContainer,\n    // add(<config>);\n    // add(<containerId>, <config>);\n    /**\n     * Adds the config for a new container. The container ID may be passed in the configuration\n     * object. If no container ID is supplied, a new container ID will be generated.\n     *\n     * @function\n     * @param {String|Object} containerIdOrConfig  Configuration object or container ID\n     * @param {Object}        [config]             Configuration object if container ID supplied\n     *                                             in `containerIdOrConfig`\n     * @returns {String} The container ID of the container\n     * @public\n     */\n    add: _container.addContainer,\n    unmount: function unmount(containerId) {\n      if (!containerId || typeof containerId !== 'string') {\n        throw new Error('Please assign the \"containerId\"!');\n      }\n      (0, _container.unmountContainer)(containerId);\n    },\n    /**\n     * Removes a container from Spotlight\n     *\n     * @param {String} containerId Container ID to remove\n     * @returns {Boolean} `true` if container removed, `false` if container does not exist\n     * @public\n     */\n    remove: function remove(containerId) {\n      if (!containerId || typeof containerId !== 'string') {\n        throw new Error('Please assign the \"containerId\"!');\n      }\n      if ((0, _container.getContainerConfig)(containerId)) {\n        (0, _container.removeContainer)(containerId);\n        if ((0, _container.getLastContainer)() === containerId) {\n          Spotlight.setActiveContainer(null);\n        }\n        return true;\n      }\n      return false;\n    },\n    /**\n     * Disables the selector rules of the specified container\n     *\n     * @param {String} containerId Container ID selector rules to disable\n     * @returns {Boolean} `true` if container's selector rules are disabled, `false` if container does not exist\n     * @public\n     */\n    disableSelector: function disableSelector(containerId) {\n      if ((0, _container.isContainer)(containerId)) {\n        (0, _container.configureContainer)(containerId, {\n          selectorDisabled: false\n        });\n        return true;\n      }\n      return false;\n    },\n    /**\n     * Enables the selector rules of the specified container\n     *\n     * @param {String} containerId Container ID selector rules to enable\n     * @returns {Boolean} `true` if container's selector rules are enabled, `false` if container does not exist\n     * @public\n     */\n    enableSelector: function enableSelector(containerId) {\n      if ((0, _container.isContainer)(containerId)) {\n        (0, _container.configureContainer)(containerId, {\n          selectorDisabled: false\n        });\n        return true;\n      }\n      return false;\n    },\n    /**\n     * Pauses Spotlight\n     *\n     * @function\n     * @returns {undefined}\n     * @public\n     */\n    pause: _Pause.pause,\n    /**\n     * Resumes Spotlight\n     *\n     * @function\n     * @returns {undefined}\n     * @public\n     */\n    resume: _Pause.resume,\n    // focus()\n    // focus(<containerId>)\n    // focus(<extSelector>)\n    /**\n     * Focuses the specified component ID, container ID, element selector, or the default\n     * container.\n     *\n     * If Spotlight is in pointer mode, focus is not changed but `elem` will be set as the last\n     * focused element of its spotlight containers.\n     *\n     * @param {String|Node} [elem] The spotlight ID or selector for either a spottable\n     *  component or a spotlight container, or spottable node. If not supplied, the default\n     *  container will be focused.\n     * @param {Object} [containerOption] The object including `enterTo` and `toOuterContainer`.\n     *  It works when the first parameter `elem` is either a spotlight container ID or a spotlight container node.\n     * @param {('last-focused'|'default-element'|'topmost')} [containerOption.enterTo] Specifies preferred\n     *  `enterTo` configuration.\n     * @param {Boolean} [containerOption.toOuterContainer] If the proper target is not found, search one\n     *  recursively to outer container.\n     * @returns {Boolean} `true` if focus successful, `false` if not.\n     * @public\n     */\n    focus: function focus(elem) {\n      var containerOption = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var target = elem;\n      var wasContainerId = false;\n      var currentContainerNode = null;\n      if (!elem) {\n        target = (0, _target.getTargetByContainer)();\n      } else if (typeof elem === 'string') {\n        if ((0, _container.getContainerConfig)(elem)) {\n          target = (0, _target.getTargetByContainer)(elem, containerOption.enterTo);\n          wasContainerId = true;\n          currentContainerNode = (0, _container.getContainerNode)(elem);\n        } else if (/^[\\w\\d-]+$/.test(elem)) {\n          // support component IDs consisting of alphanumeric, dash, or underscore\n          target = (0, _target.getTargetBySelector)(\"[data-spotlight-id=\".concat(elem, \"]\"));\n        } else {\n          target = (0, _target.getTargetBySelector)(elem);\n        }\n      } else if ((0, _container.isContainer)(elem)) {\n        target = (0, _target.getTargetByContainer)((0, _container.getContainerId)(elem), containerOption.enterTo);\n        currentContainerNode = elem;\n      }\n      var nextContainerIds = (0, _container.getContainersForNode)(target);\n      var nextContainerId = (0, _last[\"default\"])(nextContainerIds);\n      if ((0, _container.isNavigable)(target, nextContainerId, true)) {\n        var focused = focusElement(target, nextContainerIds);\n        if (!focused && wasContainerId) {\n          (0, _container.setLastContainer)(elem);\n        }\n        return focused;\n      } else if (wasContainerId) {\n        // if we failed to find a spottable target within the provided container, we'll set\n        // it as the active container to allow it to focus itself if its contents change\n        (0, _container.setLastContainer)(elem);\n      }\n      if (containerOption.toOuterContainer && currentContainerNode) {\n        var outerContainer = (0, _container.getContainersForNode)(currentContainerNode.parentElement).pop();\n        if (outerContainer) {\n          return this.focus(outerContainer, containerOption);\n        }\n      }\n      return false;\n    },\n    // move(<direction>)\n    // move(<direction>, <selector>)\n    /**\n     * Moves focus to the next spottable control in the direction specified. Optionally, a source\n     * element selector may be supplied as the starting point.\n     *\n     * @param {String} direction Direction to move, one of `'left'`, `'right'`, `'up'` or `'down'`\n     * @param {String|undefined} selector If supplied, the element to move from. If not supplied,\n     *\tthe currently focused item will be used.\n     * @returns {Boolean} `true` if focus successful, `false` if not.\n     * @public\n     */\n    move: function move(direction, selector) {\n      direction = direction.toLowerCase();\n      if (direction !== 'up' && direction !== 'down' && direction !== 'left' && direction !== 'right') {\n        return false;\n      }\n      var elem = selector ? (0, _utils.parseSelector)(selector)[0] : _getCurrent();\n      if (!elem) {\n        return false;\n      }\n      var containerIds = (0, _container.getContainersForNode)(elem);\n      if (!containerIds.length) {\n        return false;\n      }\n      return spotNext(direction, elem, containerIds);\n    },\n    /**\n     * Sets or clears the default container that will receive focus.\n     *\n     * @function\n     * @param {String} [containerId] The container ID or a falsy value to clear default\n     *                               container\n     * @returns {undefined}\n     * @public\n     */\n    setDefaultContainer: _container.setDefaultContainer,\n    /**\n     * Gets the currently active container.\n     *\n     * @returns {String} The id of the currently active container\n     * @public\n     */\n    getActiveContainer: function getActiveContainer() {\n      return (0, _container.getLastContainer)() || _container.rootContainerId;\n    },\n    /**\n     * Sets the currently active container.\n     *\n     * Note: If the current container is restricted to 'self-only' and `containerId` is not\n     * contained within the current container then the active container will not be updated.\n     *\n     * @param {String} [containerId] The id of the currently active container. If this is not\n     *\tprovided, the root container is set as the currently active container.\n     * @public\n     */\n    setActiveContainer: function setActiveContainer(containerId) {\n      if ((0, _container.mayActivateContainer)(containerId)) {\n        (0, _container.setLastContainer)(containerId || _container.rootContainerId);\n      }\n    },\n    /**\n     * Gets the current pointer mode\n     *\n     * @function\n     * @returns {Boolean} `true` if spotlight is in pointer mode\n     * @public\n     */\n    getPointerMode: _pointer.getPointerMode,\n    /**\n     * Sets the current pointer mode\n     *\n     * @function\n     * @param {Boolean} pointerMode The value of the pointer mode. This determines how\n     *\tspotlight manages focus change behaviors.\n     * @public\n     */\n    setPointerMode: _pointer.setPointerMode,\n    /**\n     * Gets the muted mode value of a spottable element.\n     *\n     * @param {Object} elem The dom element used to determine the muted status.\n     * @returns {Boolean} `true` if the passed-in control is in muted mode.\n     * @public\n     */\n    isMuted: function isMuted(elem) {\n      if (!elem) {\n        return false;\n      }\n      return (0, _utils.matchSelector)('[data-spotlight-container-muted=\"true\"] .' + _Spottable.spottableClass, elem);\n    },\n    /**\n     * Determines whether Spotlight is currently paused.\n     *\n     * @function\n     * @returns {Boolean} `true` if Spotlight is currently paused.\n     * @public\n     */\n    isPaused: _Pause.isPaused,\n    /**\n     * Determines whether an element is spottable.\n     *\n     * @param {Object} elem The dom element used to determine the spottable status.\n     * @returns {Boolean} `true` if the element being evaluated is currently spottable.\n     * @public\n     */\n    isSpottable: function isSpottable(elem) {\n      if (!elem) {\n        return false;\n      }\n      return (0, _target.isFocusable)(elem);\n    },\n    /**\n     * Returns the currently spotted control.\n     *\n     * @returns {Node} The control that currently has focus, if available\n     * @public\n     */\n    getCurrent: function getCurrent() {\n      return _getCurrent();\n    },\n    /**\n     * Returns a list of spottable elements wrapped by the supplied container.\n     *\n     * @param {String} containerId The id of the container used to determine the list of spottable elements\n     * @returns {Node[]} The spottable elements that are wrapped by the supplied container\n     * @public\n     */\n    getSpottableDescendants: function getSpottableDescendants(containerId) {\n      if (!containerId || typeof containerId !== 'string') {\n        throw new Error('Please assign the \"containerId\"!');\n      }\n      return (0, _container.getSpottableDescendants)(containerId);\n    },\n    /**\n     * Focuses the next spottable control from the position specified in the direction specified.\n     *\n     * @param {String} direction Direction to move, one of `'left'`, `'right'`, `'up'`, or `'down'`\n     * @param {Object} position `x` and `y` coordinates for the pointer\n     * @private\n     */\n    focusNextFromPoint: spotNextFromPoint\n  };\n  return exports;\n}();\nexports.Spotlight = Spotlight;\nvar _default = Spotlight;\nexports[\"default\"] = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","getDirection","Spotlight","_keymap","require","_snapshot","_platform","_interopRequireDefault","_last","_Accelerator","_Spottable","_Pause","_inputType","_utils","_container","_pointer","_target","obj","__esModule","isDown","is","isEnter","isLeft","isRight","isUp","keyCode","SpotlightAccelerator","_initialized","_duringFocusChange","_focusRingElement","_5WayKeyHold","_spotOnWindowFocus","_pointerMoveDuringKeyPress","preventDefault","evt","stopPropagation","shouldPreventNavigation","isPaused","getAllContainerIds","length","_getCurrent","isWindowReady","activeElement","document","body","setPlatformPointerMode","palmSystem","window","PalmSystem","cursor","setPointerMode","visibility","focusElement","elem","containerIds","fromPointer","_window$PalmSystem$cu","getPointerMode","getInputType","setContainerLastFocusedElement","currentFocusedElement","focusOptions","isWithinOverflowContainer","preventScroll","silentFocus","focus","focusChanged","elemRect","getBoundingClientRect","style","left","concat","x","scrollX","top","y","scrollY","width","height","getContainersForNode","containerId","setLastContainer","process","env","NODE_ENV","assignFocusPreview","restoreFocus","lastContainerId","getLastContainer","next","position","getLastPointerPosition","getContainerNode","reverse","lastFocusedElement","getContainerLastFocusedElement","isContainer","_getContainerConfig","getContainerConfig","lastContainerNode","contains","overflow","getNearestTargetFromPosition","unshift","rootContainerId","reduce","focused","target","directions","nextClassBase","spottableClass","forEach","dir","nextClass","prevElems","parseSelector","prevElem","classList","remove","nextElem","getTargetByDirectionFromElement","add","spotNextFromPoint","direction","getActiveContainer","getTargetByDirectionFromPosition","setContainerPreviousTarget","spotNext","currentContainerIds","currentContainerId","nextContainerIds","indexOf","isContainer5WayHoldable","notifyLeaveContainer","notifyEnterContainer","notifyLeaveContainerFail","onAcceleratedKeyDown","onBlur","current","blur","handleWebOSMouseEvent","ev","detail","type","handleKeyboardStateChangeEvent","_ref","onFocus","_getContainerConfig2","onKeyUp","reset","handlePointerHide","onKeyDown","notifyKeyDown","pointerHandled","processKey","onMouseMove","_ref2","clientX","clientY","notifyPointerMove","update","getNavigableTarget","setLastContainerFromTarget","onMouseOver","hasPointerMoved","onTouchEnd","initialize","containerDefaults","_getContainerConfig3","addEventListener","touch","webos","configureDefaults","configureContainer","isStandardFocusableMode","querySelector","terminate","removeEventListener","clear","removeAllContainers","setDefaultContainer","set","addContainer","unmount","Error","unmountContainer","removeContainer","setActiveContainer","disableSelector","selectorDisabled","enableSelector","pause","resume","containerOption","arguments","undefined","wasContainerId","currentContainerNode","getTargetByContainer","enterTo","test","getTargetBySelector","getContainerId","nextContainerId","isNavigable","toOuterContainer","outerContainer","parentElement","pop","move","selector","toLowerCase","mayActivateContainer","isMuted","matchSelector","isSpottable","isFocusable","getCurrent","getSpottableDescendants","focusNextFromPoint","_default"],"sources":["/Users/gitchan/Projects/gitchan-yonsei/2024-enact-template/node_modules/@enact/spotlight/src/spotlight.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDirection = exports[\"default\"] = exports.Spotlight = void 0;\nvar _keymap = require(\"@enact/core/keymap\");\nvar _snapshot = require(\"@enact/core/snapshot\");\nvar _platform = _interopRequireDefault(require(\"@enact/core/platform\"));\nvar _last = _interopRequireDefault(require(\"ramda/src/last\"));\nvar _Accelerator = _interopRequireDefault(require(\"../Accelerator\"));\nvar _Spottable = require(\"../Spottable\");\nvar _Pause = require(\"../Pause\");\nvar _inputType = require(\"./inputType\");\nvar _utils = require(\"./utils\");\nvar _container = require(\"./container\");\nvar _pointer = require(\"./pointer\");\nvar _target = require(\"./target\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n/*\n * A javascript-based implementation of Spatial Navigation.\n *\n * Copyright (c) 2016 Luke Chang.\n * https://github.com/luke-chang/js-spatial-navigation\n *\n * Licensed under the MPL license.\n */\n\n/**\n * Exports the {@link spotlight.Spotlight} object used for controlling spotlight behavior and the\n * {@link spotlight.Spotlight.getDirection} function for mapping a keycode to a spotlight direction.\n *\n * The default export is {@link spotlight.Spotlight}.\n *\n * @module spotlight\n * @exports default Spotlight\n * @exports getDirection\n */\n\nvar isDown = (0, _keymap.is)('down');\nvar isEnter = (0, _keymap.is)('enter');\nvar isLeft = (0, _keymap.is)('left');\nvar isRight = (0, _keymap.is)('right');\nvar isUp = (0, _keymap.is)('up');\n\n/**\n * Translates keyCodes into 5-way direction descriptions (e.g. `'down'`)\n *\n * @function\n * @memberof spotlight\n * @param {Number} keyCode - Key code to analyze\n * @returns {String|false} - One of `'up'`, `'down'`, `'left'`, `'right'` or `false` if not a direction key\n * @public\n */\nvar getDirection = function getDirection(keyCode) {\n  return isDown(keyCode) && 'down' || isLeft(keyCode) && 'left' || isRight(keyCode) && 'right' || isUp(keyCode) && 'up';\n};\nexports.getDirection = getDirection;\nvar SpotlightAccelerator = new _Accelerator[\"default\"]();\n\n/**\n * Provides 5-way navigation and focus support\n *\n * ```\n * import Spotlight from '@enact/Spotlight';\n *\n * // get the currently focused component\n * const current = Spotlight.getCurrent();\n *\n * // focus an element by CSS selector\n * Spotlight.focus('.my-custom-class');\n *\n * // is `current` focusable?\n * const isFocused = Spotlight.isSpottable(current);\n * ```\n *\n * @type {Object}\n * @memberof spotlight\n * @public\n */\nvar Spotlight = function () {\n  'use strict';\n\n  /*\n  /* private vars\n  */\n  var _initialized = false;\n  var _duringFocusChange = false;\n  var _focusRingElement = null;\n\n  /*\n   * Whether a 5-way directional key is being held.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  var _5WayKeyHold = false;\n\n  /*\n   * Whether to set focus during the next window focus event\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  var _spotOnWindowFocus = false;\n\n  /*\n   * `true` when a pointer move event occurs during a keypress. Used to short circuit key down\n   * handling until the next keyup occurs.\n   *\n   * @type {Boolean}\n   * @default false\n   */\n  var _pointerMoveDuringKeyPress = false;\n\n  /*\n  * protected methods\n  */\n\n  function preventDefault(evt) {\n    evt.preventDefault();\n    evt.stopPropagation();\n    return false;\n  }\n  function shouldPreventNavigation() {\n    return (0, _Pause.isPaused)() || (0, _container.getAllContainerIds)().length === 0;\n  }\n  function _getCurrent() {\n    if (!(0, _snapshot.isWindowReady)()) return;\n    var activeElement = document.activeElement;\n    if (activeElement && activeElement !== document.body) {\n      return activeElement;\n    }\n  }\n\n  // An extension point for updating pointer mode based on the current platform.\n  // Currently only webOS\n  function setPlatformPointerMode() {\n    var palmSystem = window.PalmSystem;\n    if (palmSystem && palmSystem.cursor) {\n      (0, _pointer.setPointerMode)(palmSystem.cursor.visibility);\n    }\n  }\n  function focusElement(elem, containerIds, fromPointer) {\n    var _window$PalmSystem$cu;\n    if (!elem) {\n      return false;\n    }\n    if ((0, _pointer.getPointerMode)() && !fromPointer && ((0, _inputType.getInputType)() === 'touch' || typeof window !== 'undefined' && (!window.PalmSystem || (_window$PalmSystem$cu = window.PalmSystem.cursor) !== null && _window$PalmSystem$cu !== void 0 && _window$PalmSystem$cu.visibility))) {\n      (0, _container.setContainerLastFocusedElement)(elem, containerIds);\n      return false;\n    }\n    var currentFocusedElement = _getCurrent();\n    if (elem === currentFocusedElement) {\n      return true;\n    }\n    var focusOptions = (0, _container.isWithinOverflowContainer)(elem, containerIds) ? {\n      preventScroll: true\n    } : null;\n    var silentFocus = function silentFocus() {\n      elem.focus(focusOptions);\n      focusChanged(elem, containerIds);\n    };\n    if (_duringFocusChange) {\n      silentFocus();\n      return true;\n    }\n    _duringFocusChange = true;\n    if ((0, _Pause.isPaused)()) {\n      silentFocus();\n      _duringFocusChange = false;\n      return true;\n    }\n    elem.focus(focusOptions);\n\n    /* istanbul ignore next */\n    if (_focusRingElement) {\n      var elemRect = elem.getBoundingClientRect();\n      _focusRingElement.style.left = \"\".concat(elemRect.x + window.scrollX, \"px\");\n      _focusRingElement.style.top = \"\".concat(elemRect.y + window.scrollY, \"px\");\n      _focusRingElement.style.width = \"\".concat(elemRect.width, \"px\");\n      _focusRingElement.style.height = \"\".concat(elemRect.height, \"px\");\n    }\n    _duringFocusChange = false;\n    focusChanged(elem, containerIds);\n    return true;\n  }\n  function focusChanged(elem, containerIds) {\n    if (!containerIds || !containerIds.length) {\n      containerIds = (0, _container.getContainersForNode)(elem);\n    }\n    var containerId = (0, _last[\"default\"])(containerIds);\n    if (containerId) {\n      (0, _container.setContainerLastFocusedElement)(elem, containerIds);\n      (0, _container.setLastContainer)(containerId);\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n      assignFocusPreview(elem);\n    }\n  }\n  function restoreFocus() {\n    var lastContainerId = (0, _container.getLastContainer)();\n    var next;\n    if (lastContainerId) {\n      var position = (0, _pointer.getLastPointerPosition)();\n\n      // walk up the chain of containers from the last to attempt to find a target\n      next = (0, _container.getContainersForNode)((0, _container.getContainerNode)(lastContainerId)).reverse();\n\n      // only prepend last focused if it exists so that Spotlight.focus() doesn't receive\n      // a falsy target\n      var lastFocusedElement = (0, _container.getContainerLastFocusedElement)(lastContainerId);\n      while ((0, _container.isContainer)(lastFocusedElement)) {\n        var _getContainerConfig = (0, _container.getContainerConfig)(lastFocusedElement);\n        lastFocusedElement = _getContainerConfig.lastFocusedElement;\n      }\n      var lastContainerNode = (0, _container.getContainerNode)(lastContainerId);\n      if (!lastFocusedElement || lastContainerNode.getBoundingClientRect && lastFocusedElement.getBoundingClientRect && !(0, _utils.contains)(lastContainerNode.getBoundingClientRect(), lastFocusedElement.getBoundingClientRect())) {\n        lastFocusedElement = (0, _container.getContainerConfig)(lastContainerId).overflow && (0, _target.getNearestTargetFromPosition)(position, lastContainerId);\n      }\n      if (lastFocusedElement) {\n        next.unshift(lastFocusedElement);\n      }\n    } else {\n      next = [_container.rootContainerId];\n    }\n\n    // attempt to find a target starting with the last focused element in the last\n    // container, followed by the last container, and finally the root container\n    return next.reduce(function (focused, target) {\n      return focused || Spotlight.focus(target);\n    }, false);\n  }\n\n  // The below should be gated on non-production environment only.\n  function assignFocusPreview(elem) {\n    var directions = ['up', 'right', 'down', 'left'],\n      nextClassBase = _Spottable.spottableClass + '-next-';\n\n    // Remove all previous targets\n    directions.forEach(function (dir) {\n      var nextClass = nextClassBase + dir,\n        prevElems = (0, _utils.parseSelector)('.' + nextClass);\n      if (prevElems && prevElems.length !== 0) {\n        prevElems.forEach(function (prevElem) {\n          return prevElem.classList.remove(nextClass);\n        });\n      }\n    });\n\n    // Find all next targets and identify them\n    directions.forEach(function (dir) {\n      var nextElem = (0, _target.getTargetByDirectionFromElement)(dir, elem);\n      if (nextElem) {\n        nextElem.classList.add(nextClassBase + dir);\n      }\n    });\n  }\n  function spotNextFromPoint(direction, position) {\n    var containerId = Spotlight.getActiveContainer();\n    var next = (0, _target.getTargetByDirectionFromPosition)(direction, position, containerId);\n    if (next) {\n      (0, _container.setContainerPreviousTarget)(containerId, direction, next, (0, _container.getContainerLastFocusedElement)(containerId));\n      return focusElement(next, (0, _container.getContainersForNode)(next));\n    }\n    return false;\n  }\n  function spotNext(direction, currentFocusedElement, currentContainerIds) {\n    var next = (0, _target.getTargetByDirectionFromElement)(direction, currentFocusedElement);\n    if (next) {\n      var currentContainerId = (0, _last[\"default\"])(currentContainerIds);\n      var nextContainerIds = (0, _container.getContainersForNode)(next);\n\n      // prevent focus if 5-way is being held and the next element isn't wrapped by\n      // the current element's immediate container\n      if (_5WayKeyHold && nextContainerIds.indexOf(currentContainerId) < 0 && !(0, _container.isContainer5WayHoldable)(currentContainerId)) {\n        return false;\n      }\n      (0, _container.notifyLeaveContainer)(direction, currentFocusedElement, currentContainerIds, next, nextContainerIds);\n      (0, _container.setContainerPreviousTarget)(currentContainerId, direction, next, currentFocusedElement);\n      var focused = focusElement(next, nextContainerIds);\n      (0, _container.notifyEnterContainer)(direction, currentFocusedElement, currentContainerIds, next, nextContainerIds);\n      return focused;\n    }\n    (0, _container.notifyLeaveContainerFail)(direction, currentFocusedElement, currentContainerIds);\n    return false;\n  }\n  function onAcceleratedKeyDown(evt) {\n    var direction = getDirection(evt.keyCode);\n    if (!direction) return;\n    var currentFocusedElement = _getCurrent();\n    var currentContainerIds = (0, _container.getContainersForNode)(currentFocusedElement);\n    spotNext(direction, currentFocusedElement, currentContainerIds);\n  }\n  function onBlur() {\n    var current = _getCurrent();\n    if (current) {\n      current.blur();\n    }\n    Spotlight.setPointerMode(false);\n    _spotOnWindowFocus = true;\n    _pointerMoveDuringKeyPress = false;\n  }\n  function handleWebOSMouseEvent(ev) {\n    if (!(0, _Pause.isPaused)() && ev && ev.detail && ev.detail.type === 'Leave') {\n      onBlur();\n    }\n  }\n  function handleKeyboardStateChangeEvent(_ref) {\n    var visibility = _ref.visibility;\n    if (!visibility) {\n      setPlatformPointerMode();\n    }\n  }\n  function onFocus() {\n    // Normally, there isn't focus here unless the window has been blurred above. On webOS, the\n    // platform may focus the window after the app has already focused a component so we prevent\n    // trying to focus something else (potentially) unless the window was previously blurred\n    if (_spotOnWindowFocus) {\n      setPlatformPointerMode();\n\n      // If the window was previously blurred while in pointer mode, the last active containerId may\n      // not have yet set focus to its spottable elements. For this reason we can't rely on setting focus\n      // to the last focused element of the last active containerId, so we use rootContainerId instead\n      var lastFocusedElement = (0, _container.getContainerLastFocusedElement)(_container.rootContainerId);\n      while ((0, _container.isContainer)(lastFocusedElement)) {\n        var _getContainerConfig2 = (0, _container.getContainerConfig)(lastFocusedElement);\n        lastFocusedElement = _getContainerConfig2.lastFocusedElement;\n      }\n      if (!Spotlight.focus(lastFocusedElement)) {\n        // If the last focused element was previously also disabled (or no longer exists), we\n        // need to set focus somewhere\n        Spotlight.focus();\n      }\n      _spotOnWindowFocus = false;\n    }\n  }\n  function onKeyUp(evt) {\n    _pointerMoveDuringKeyPress = false;\n    var keyCode = evt.keyCode;\n    if (getDirection(keyCode) || isEnter(keyCode)) {\n      SpotlightAccelerator.reset();\n      _5WayKeyHold = false;\n    }\n  }\n  function handlePointerHide() {\n    if (!_getCurrent()) {\n      restoreFocus();\n    }\n  }\n  function onKeyDown(evt) {\n    if (shouldPreventNavigation()) {\n      (0, _pointer.notifyKeyDown)(evt.keyCode);\n      return;\n    }\n    var keyCode = evt.keyCode;\n    var direction = getDirection(keyCode);\n    var pointerHandled = (0, _pointer.notifyKeyDown)(keyCode, handlePointerHide);\n    if (pointerHandled || !(direction || isEnter(keyCode))) {\n      return;\n    }\n    if (!(0, _Pause.isPaused)() && !_pointerMoveDuringKeyPress) {\n      if (_getCurrent()) {\n        SpotlightAccelerator.processKey(evt, onAcceleratedKeyDown);\n      } else if (!spotNextFromPoint(direction, (0, _pointer.getLastPointerPosition)())) {\n        restoreFocus();\n      }\n      _5WayKeyHold = true;\n    }\n    if (direction) {\n      preventDefault(evt);\n    }\n  }\n  function onMouseMove(_ref2) {\n    var target = _ref2.target,\n      clientX = _ref2.clientX,\n      clientY = _ref2.clientY;\n    if (shouldPreventNavigation()) {\n      (0, _pointer.notifyPointerMove)(null, target, clientX, clientY);\n      return;\n    }\n    var current = _getCurrent();\n    var update = (0, _pointer.notifyPointerMove)(current, target, clientX, clientY);\n    if (update) {\n      if (_5WayKeyHold) {\n        _pointerMoveDuringKeyPress = true;\n      }\n      var next = (0, _target.getNavigableTarget)(target);\n\n      // TODO: Consider encapsulating this work within focusElement\n      if (next !== current) {\n        if (next) {\n          focusElement(next, (0, _container.getContainersForNode)(next), true);\n          return true;\n        } else if (current) {\n          current.blur();\n          (0, _container.setLastContainerFromTarget)(current, target);\n        }\n      }\n    }\n  }\n  function onMouseOver(evt) {\n    if (shouldPreventNavigation()) return;\n    var target = evt.target;\n    if ((0, _pointer.getPointerMode)() && (0, _pointer.hasPointerMoved)(evt.clientX, evt.clientY)) {\n      var next = (0, _target.getNavigableTarget)(target); // account for child controls\n\n      if (next && next !== _getCurrent()) {\n        focusElement(next, (0, _container.getContainersForNode)(next), true);\n        return true;\n      }\n      preventDefault(evt);\n    }\n  }\n  function onTouchEnd(evt) {\n    var current = _getCurrent();\n    if (current && !current.contains(evt.target)) {\n      current.blur();\n    }\n  }\n\n  /*\n   * public methods\n   */\n  var exports = /** @lends spotlight.Spotlight */{\n    // eslint-disable-line no-shadow\n    /**\n     * Initializes Spotlight. This is generally handled by\n     * {@link spotlight/SpotlightRootDecorator.SpotlightRootDecorator}.\n     *\n     * @param {Object} containerDefaults Default configuration for new spotlight containers\n     * @returns {undefined}\n     * @public\n     */\n    initialize: function initialize(containerDefaults) {\n      if (!_initialized) {\n        var _getContainerConfig3;\n        window.addEventListener('blur', onBlur);\n        window.addEventListener('focus', onFocus);\n        window.addEventListener('keydown', onKeyDown);\n        window.addEventListener('keyup', onKeyUp);\n        window.addEventListener('mouseover', onMouseOver);\n        window.addEventListener('mousemove', onMouseMove);\n        if (_platform[\"default\"].touch) {\n          window.addEventListener('touchend', onTouchEnd);\n        }\n        if (_platform[\"default\"].webos) {\n          window.top.document.addEventListener('webOSMouse', handleWebOSMouseEvent);\n          window.top.document.addEventListener('keyboardStateChange', handleKeyboardStateChangeEvent);\n        }\n        (0, _container.setLastContainer)(_container.rootContainerId);\n        (0, _container.configureDefaults)(containerDefaults);\n        (0, _container.configureContainer)(_container.rootContainerId);\n        // by default, pointer mode is off but the platform's current state will override that\n        (0, _pointer.setPointerMode)(false);\n        setPlatformPointerMode();\n\n        /* istanbul ignore next */\n        if ((_getContainerConfig3 = (0, _container.getContainerConfig)('spotlightRootDecorator')) !== null && _getContainerConfig3 !== void 0 && _getContainerConfig3.isStandardFocusableMode) {\n          _focusRingElement = document.querySelector('#spotlightFocusRing');\n        }\n        _initialized = true;\n      }\n    },\n    /**\n     * Terminates Spotlight. This is generally handled by {@link spotlight.SpotlightRootDecorator}.\n     *\n     * @public\n     */\n    terminate: function terminate() {\n      window.removeEventListener('blur', onBlur);\n      window.removeEventListener('focus', onFocus);\n      window.removeEventListener('keydown', onKeyDown);\n      window.removeEventListener('keyup', onKeyUp);\n      window.removeEventListener('mouseover', onMouseOver);\n      window.removeEventListener('mousemove', onMouseMove);\n      if (_platform[\"default\"].touch) {\n        window.removeEventListener('touchend', onTouchEnd);\n      }\n      if (_platform[\"default\"].webos) {\n        window.top.document.removeEventListener('webOSMouse', handleWebOSMouseEvent);\n        window.top.document.removeEventListener('keyboardStateChange', handleKeyboardStateChangeEvent);\n      }\n      Spotlight.clear();\n      _initialized = false;\n    },\n    /**\n     * Resets spotlight container information\n     *\n     * @private\n     */\n    clear: function clear() {\n      (0, _container.removeAllContainers)();\n      (0, _container.setDefaultContainer)();\n      (0, _container.setLastContainer)();\n      _duringFocusChange = false;\n    },\n    // set(<config>);\n    // set(<containerId>, <config>);\n    /**\n     * Sets the config for spotlight or the specified containerID\n     *\n     * @function\n     * @param {String|Object} containerIdOrConfig  Configuration object or container ID\n     * @param {Object}        [config]             Configuration object if container ID supplied\n     *                                             in `containerIdOrConfig`\n     * @returns {undefined}\n     * @public\n     */\n    set: _container.configureContainer,\n    // add(<config>);\n    // add(<containerId>, <config>);\n    /**\n     * Adds the config for a new container. The container ID may be passed in the configuration\n     * object. If no container ID is supplied, a new container ID will be generated.\n     *\n     * @function\n     * @param {String|Object} containerIdOrConfig  Configuration object or container ID\n     * @param {Object}        [config]             Configuration object if container ID supplied\n     *                                             in `containerIdOrConfig`\n     * @returns {String} The container ID of the container\n     * @public\n     */\n    add: _container.addContainer,\n    unmount: function unmount(containerId) {\n      if (!containerId || typeof containerId !== 'string') {\n        throw new Error('Please assign the \"containerId\"!');\n      }\n      (0, _container.unmountContainer)(containerId);\n    },\n    /**\n     * Removes a container from Spotlight\n     *\n     * @param {String} containerId Container ID to remove\n     * @returns {Boolean} `true` if container removed, `false` if container does not exist\n     * @public\n     */\n    remove: function remove(containerId) {\n      if (!containerId || typeof containerId !== 'string') {\n        throw new Error('Please assign the \"containerId\"!');\n      }\n      if ((0, _container.getContainerConfig)(containerId)) {\n        (0, _container.removeContainer)(containerId);\n        if ((0, _container.getLastContainer)() === containerId) {\n          Spotlight.setActiveContainer(null);\n        }\n        return true;\n      }\n      return false;\n    },\n    /**\n     * Disables the selector rules of the specified container\n     *\n     * @param {String} containerId Container ID selector rules to disable\n     * @returns {Boolean} `true` if container's selector rules are disabled, `false` if container does not exist\n     * @public\n     */\n    disableSelector: function disableSelector(containerId) {\n      if ((0, _container.isContainer)(containerId)) {\n        (0, _container.configureContainer)(containerId, {\n          selectorDisabled: false\n        });\n        return true;\n      }\n      return false;\n    },\n    /**\n     * Enables the selector rules of the specified container\n     *\n     * @param {String} containerId Container ID selector rules to enable\n     * @returns {Boolean} `true` if container's selector rules are enabled, `false` if container does not exist\n     * @public\n     */\n    enableSelector: function enableSelector(containerId) {\n      if ((0, _container.isContainer)(containerId)) {\n        (0, _container.configureContainer)(containerId, {\n          selectorDisabled: false\n        });\n        return true;\n      }\n      return false;\n    },\n    /**\n     * Pauses Spotlight\n     *\n     * @function\n     * @returns {undefined}\n     * @public\n     */\n    pause: _Pause.pause,\n    /**\n     * Resumes Spotlight\n     *\n     * @function\n     * @returns {undefined}\n     * @public\n     */\n    resume: _Pause.resume,\n    // focus()\n    // focus(<containerId>)\n    // focus(<extSelector>)\n    /**\n     * Focuses the specified component ID, container ID, element selector, or the default\n     * container.\n     *\n     * If Spotlight is in pointer mode, focus is not changed but `elem` will be set as the last\n     * focused element of its spotlight containers.\n     *\n     * @param {String|Node} [elem] The spotlight ID or selector for either a spottable\n     *  component or a spotlight container, or spottable node. If not supplied, the default\n     *  container will be focused.\n     * @param {Object} [containerOption] The object including `enterTo` and `toOuterContainer`.\n     *  It works when the first parameter `elem` is either a spotlight container ID or a spotlight container node.\n     * @param {('last-focused'|'default-element'|'topmost')} [containerOption.enterTo] Specifies preferred\n     *  `enterTo` configuration.\n     * @param {Boolean} [containerOption.toOuterContainer] If the proper target is not found, search one\n     *  recursively to outer container.\n     * @returns {Boolean} `true` if focus successful, `false` if not.\n     * @public\n     */\n    focus: function focus(elem) {\n      var containerOption = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var target = elem;\n      var wasContainerId = false;\n      var currentContainerNode = null;\n      if (!elem) {\n        target = (0, _target.getTargetByContainer)();\n      } else if (typeof elem === 'string') {\n        if ((0, _container.getContainerConfig)(elem)) {\n          target = (0, _target.getTargetByContainer)(elem, containerOption.enterTo);\n          wasContainerId = true;\n          currentContainerNode = (0, _container.getContainerNode)(elem);\n        } else if (/^[\\w\\d-]+$/.test(elem)) {\n          // support component IDs consisting of alphanumeric, dash, or underscore\n          target = (0, _target.getTargetBySelector)(\"[data-spotlight-id=\".concat(elem, \"]\"));\n        } else {\n          target = (0, _target.getTargetBySelector)(elem);\n        }\n      } else if ((0, _container.isContainer)(elem)) {\n        target = (0, _target.getTargetByContainer)((0, _container.getContainerId)(elem), containerOption.enterTo);\n        currentContainerNode = elem;\n      }\n      var nextContainerIds = (0, _container.getContainersForNode)(target);\n      var nextContainerId = (0, _last[\"default\"])(nextContainerIds);\n      if ((0, _container.isNavigable)(target, nextContainerId, true)) {\n        var focused = focusElement(target, nextContainerIds);\n        if (!focused && wasContainerId) {\n          (0, _container.setLastContainer)(elem);\n        }\n        return focused;\n      } else if (wasContainerId) {\n        // if we failed to find a spottable target within the provided container, we'll set\n        // it as the active container to allow it to focus itself if its contents change\n        (0, _container.setLastContainer)(elem);\n      }\n      if (containerOption.toOuterContainer && currentContainerNode) {\n        var outerContainer = (0, _container.getContainersForNode)(currentContainerNode.parentElement).pop();\n        if (outerContainer) {\n          return this.focus(outerContainer, containerOption);\n        }\n      }\n      return false;\n    },\n    // move(<direction>)\n    // move(<direction>, <selector>)\n    /**\n     * Moves focus to the next spottable control in the direction specified. Optionally, a source\n     * element selector may be supplied as the starting point.\n     *\n     * @param {String} direction Direction to move, one of `'left'`, `'right'`, `'up'` or `'down'`\n     * @param {String|undefined} selector If supplied, the element to move from. If not supplied,\n     *\tthe currently focused item will be used.\n     * @returns {Boolean} `true` if focus successful, `false` if not.\n     * @public\n     */\n    move: function move(direction, selector) {\n      direction = direction.toLowerCase();\n      if (direction !== 'up' && direction !== 'down' && direction !== 'left' && direction !== 'right') {\n        return false;\n      }\n      var elem = selector ? (0, _utils.parseSelector)(selector)[0] : _getCurrent();\n      if (!elem) {\n        return false;\n      }\n      var containerIds = (0, _container.getContainersForNode)(elem);\n      if (!containerIds.length) {\n        return false;\n      }\n      return spotNext(direction, elem, containerIds);\n    },\n    /**\n     * Sets or clears the default container that will receive focus.\n     *\n     * @function\n     * @param {String} [containerId] The container ID or a falsy value to clear default\n     *                               container\n     * @returns {undefined}\n     * @public\n     */\n    setDefaultContainer: _container.setDefaultContainer,\n    /**\n     * Gets the currently active container.\n     *\n     * @returns {String} The id of the currently active container\n     * @public\n     */\n    getActiveContainer: function getActiveContainer() {\n      return (0, _container.getLastContainer)() || _container.rootContainerId;\n    },\n    /**\n     * Sets the currently active container.\n     *\n     * Note: If the current container is restricted to 'self-only' and `containerId` is not\n     * contained within the current container then the active container will not be updated.\n     *\n     * @param {String} [containerId] The id of the currently active container. If this is not\n     *\tprovided, the root container is set as the currently active container.\n     * @public\n     */\n    setActiveContainer: function setActiveContainer(containerId) {\n      if ((0, _container.mayActivateContainer)(containerId)) {\n        (0, _container.setLastContainer)(containerId || _container.rootContainerId);\n      }\n    },\n    /**\n     * Gets the current pointer mode\n     *\n     * @function\n     * @returns {Boolean} `true` if spotlight is in pointer mode\n     * @public\n     */\n    getPointerMode: _pointer.getPointerMode,\n    /**\n     * Sets the current pointer mode\n     *\n     * @function\n     * @param {Boolean} pointerMode The value of the pointer mode. This determines how\n     *\tspotlight manages focus change behaviors.\n     * @public\n     */\n    setPointerMode: _pointer.setPointerMode,\n    /**\n     * Gets the muted mode value of a spottable element.\n     *\n     * @param {Object} elem The dom element used to determine the muted status.\n     * @returns {Boolean} `true` if the passed-in control is in muted mode.\n     * @public\n     */\n    isMuted: function isMuted(elem) {\n      if (!elem) {\n        return false;\n      }\n      return (0, _utils.matchSelector)('[data-spotlight-container-muted=\"true\"] .' + _Spottable.spottableClass, elem);\n    },\n    /**\n     * Determines whether Spotlight is currently paused.\n     *\n     * @function\n     * @returns {Boolean} `true` if Spotlight is currently paused.\n     * @public\n     */\n    isPaused: _Pause.isPaused,\n    /**\n     * Determines whether an element is spottable.\n     *\n     * @param {Object} elem The dom element used to determine the spottable status.\n     * @returns {Boolean} `true` if the element being evaluated is currently spottable.\n     * @public\n     */\n    isSpottable: function isSpottable(elem) {\n      if (!elem) {\n        return false;\n      }\n      return (0, _target.isFocusable)(elem);\n    },\n    /**\n     * Returns the currently spotted control.\n     *\n     * @returns {Node} The control that currently has focus, if available\n     * @public\n     */\n    getCurrent: function getCurrent() {\n      return _getCurrent();\n    },\n    /**\n     * Returns a list of spottable elements wrapped by the supplied container.\n     *\n     * @param {String} containerId The id of the container used to determine the list of spottable elements\n     * @returns {Node[]} The spottable elements that are wrapped by the supplied container\n     * @public\n     */\n    getSpottableDescendants: function getSpottableDescendants(containerId) {\n      if (!containerId || typeof containerId !== 'string') {\n        throw new Error('Please assign the \"containerId\"!');\n      }\n      return (0, _container.getSpottableDescendants)(containerId);\n    },\n    /**\n     * Focuses the next spottable control from the position specified in the direction specified.\n     *\n     * @param {String} direction Direction to move, one of `'left'`, `'right'`, `'up'`, or `'down'`\n     * @param {Object} position `x` and `y` coordinates for the pointer\n     * @private\n     */\n    focusNextFromPoint: spotNextFromPoint\n  };\n  return exports;\n}();\nexports.Spotlight = Spotlight;\nvar _default = Spotlight;\nexports[\"default\"] = _default;"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,YAAY,GAAGF,OAAO,CAAC,SAAS,CAAC,GAAGA,OAAO,CAACG,SAAS,GAAG,KAAK,CAAC;AACtE,IAAIC,OAAO,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AAC3C,IAAIC,SAAS,GAAGD,OAAO,CAAC,sBAAsB,CAAC;AAC/C,IAAIE,SAAS,GAAGC,sBAAsB,CAACH,OAAO,CAAC,sBAAsB,CAAC,CAAC;AACvE,IAAII,KAAK,GAAGD,sBAAsB,CAACH,OAAO,CAAC,gBAAgB,CAAC,CAAC;AAC7D,IAAIK,YAAY,GAAGF,sBAAsB,CAACH,OAAO,CAAC,gBAAgB,CAAC,CAAC;AACpE,IAAIM,UAAU,GAAGN,OAAO,CAAC,cAAc,CAAC;AACxC,IAAIO,MAAM,GAAGP,OAAO,CAAC,UAAU,CAAC;AAChC,IAAIQ,UAAU,GAAGR,OAAO,CAAC,aAAa,CAAC;AACvC,IAAIS,MAAM,GAAGT,OAAO,CAAC,SAAS,CAAC;AAC/B,IAAIU,UAAU,GAAGV,OAAO,CAAC,aAAa,CAAC;AACvC,IAAIW,QAAQ,GAAGX,OAAO,CAAC,WAAW,CAAC;AACnC,IAAIY,OAAO,GAAGZ,OAAO,CAAC,UAAU,CAAC;AACjC,SAASG,sBAAsBA,CAACU,GAAG,EAAE;EAAE,OAAOA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAGD,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAAE;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIE,MAAM,GAAG,CAAC,CAAC,EAAEhB,OAAO,CAACiB,EAAE,EAAE,MAAM,CAAC;AACpC,IAAIC,OAAO,GAAG,CAAC,CAAC,EAAElB,OAAO,CAACiB,EAAE,EAAE,OAAO,CAAC;AACtC,IAAIE,MAAM,GAAG,CAAC,CAAC,EAAEnB,OAAO,CAACiB,EAAE,EAAE,MAAM,CAAC;AACpC,IAAIG,OAAO,GAAG,CAAC,CAAC,EAAEpB,OAAO,CAACiB,EAAE,EAAE,OAAO,CAAC;AACtC,IAAII,IAAI,GAAG,CAAC,CAAC,EAAErB,OAAO,CAACiB,EAAE,EAAE,IAAI,CAAC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAInB,YAAY,GAAG,SAASA,YAAYA,CAACwB,OAAO,EAAE;EAChD,OAAON,MAAM,CAACM,OAAO,CAAC,IAAI,MAAM,IAAIH,MAAM,CAACG,OAAO,CAAC,IAAI,MAAM,IAAIF,OAAO,CAACE,OAAO,CAAC,IAAI,OAAO,IAAID,IAAI,CAACC,OAAO,CAAC,IAAI,IAAI;AACvH,CAAC;AACD1B,OAAO,CAACE,YAAY,GAAGA,YAAY;AACnC,IAAIyB,oBAAoB,GAAG,IAAIjB,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIP,SAAS,GAAG,YAAY;EAC1B,YAAY;;EAEZ;AACF;AACA;EACE,IAAIyB,YAAY,GAAG,KAAK;EACxB,IAAIC,kBAAkB,GAAG,KAAK;EAC9B,IAAIC,iBAAiB,GAAG,IAAI;;EAE5B;AACF;AACA;AACA;AACA;AACA;EACE,IAAIC,YAAY,GAAG,KAAK;;EAExB;AACF;AACA;AACA;AACA;AACA;EACE,IAAIC,kBAAkB,GAAG,KAAK;;EAE9B;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAIC,0BAA0B,GAAG,KAAK;;EAEtC;AACF;AACA;;EAEE,SAASC,cAAcA,CAACC,GAAG,EAAE;IAC3BA,GAAG,CAACD,cAAc,CAAC,CAAC;IACpBC,GAAG,CAACC,eAAe,CAAC,CAAC;IACrB,OAAO,KAAK;EACd;EACA,SAASC,uBAAuBA,CAAA,EAAG;IACjC,OAAO,CAAC,CAAC,EAAEzB,MAAM,CAAC0B,QAAQ,EAAE,CAAC,IAAI,CAAC,CAAC,EAAEvB,UAAU,CAACwB,kBAAkB,EAAE,CAAC,CAACC,MAAM,KAAK,CAAC;EACpF;EACA,SAASC,WAAWA,CAAA,EAAG;IACrB,IAAI,CAAC,CAAC,CAAC,EAAEnC,SAAS,CAACoC,aAAa,EAAE,CAAC,EAAE;IACrC,IAAIC,aAAa,GAAGC,QAAQ,CAACD,aAAa;IAC1C,IAAIA,aAAa,IAAIA,aAAa,KAAKC,QAAQ,CAACC,IAAI,EAAE;MACpD,OAAOF,aAAa;IACtB;EACF;;EAEA;EACA;EACA,SAASG,sBAAsBA,CAAA,EAAG;IAChC,IAAIC,UAAU,GAAGC,MAAM,CAACC,UAAU;IAClC,IAAIF,UAAU,IAAIA,UAAU,CAACG,MAAM,EAAE;MACnC,CAAC,CAAC,EAAElC,QAAQ,CAACmC,cAAc,EAAEJ,UAAU,CAACG,MAAM,CAACE,UAAU,CAAC;IAC5D;EACF;EACA,SAASC,YAAYA,CAACC,IAAI,EAAEC,YAAY,EAAEC,WAAW,EAAE;IACrD,IAAIC,qBAAqB;IACzB,IAAI,CAACH,IAAI,EAAE;MACT,OAAO,KAAK;IACd;IACA,IAAI,CAAC,CAAC,EAAEtC,QAAQ,CAAC0C,cAAc,EAAE,CAAC,IAAI,CAACF,WAAW,KAAK,CAAC,CAAC,EAAE3C,UAAU,CAAC8C,YAAY,EAAE,CAAC,KAAK,OAAO,IAAI,OAAOX,MAAM,KAAK,WAAW,KAAK,CAACA,MAAM,CAACC,UAAU,IAAI,CAACQ,qBAAqB,GAAGT,MAAM,CAACC,UAAU,CAACC,MAAM,MAAM,IAAI,IAAIO,qBAAqB,KAAK,KAAK,CAAC,IAAIA,qBAAqB,CAACL,UAAU,CAAC,CAAC,EAAE;MAClS,CAAC,CAAC,EAAErC,UAAU,CAAC6C,8BAA8B,EAAEN,IAAI,EAAEC,YAAY,CAAC;MAClE,OAAO,KAAK;IACd;IACA,IAAIM,qBAAqB,GAAGpB,WAAW,CAAC,CAAC;IACzC,IAAIa,IAAI,KAAKO,qBAAqB,EAAE;MAClC,OAAO,IAAI;IACb;IACA,IAAIC,YAAY,GAAG,CAAC,CAAC,EAAE/C,UAAU,CAACgD,yBAAyB,EAAET,IAAI,EAAEC,YAAY,CAAC,GAAG;MACjFS,aAAa,EAAE;IACjB,CAAC,GAAG,IAAI;IACR,IAAIC,WAAW,GAAG,SAASA,WAAWA,CAAA,EAAG;MACvCX,IAAI,CAACY,KAAK,CAACJ,YAAY,CAAC;MACxBK,YAAY,CAACb,IAAI,EAAEC,YAAY,CAAC;IAClC,CAAC;IACD,IAAI1B,kBAAkB,EAAE;MACtBoC,WAAW,CAAC,CAAC;MACb,OAAO,IAAI;IACb;IACApC,kBAAkB,GAAG,IAAI;IACzB,IAAI,CAAC,CAAC,EAAEjB,MAAM,CAAC0B,QAAQ,EAAE,CAAC,EAAE;MAC1B2B,WAAW,CAAC,CAAC;MACbpC,kBAAkB,GAAG,KAAK;MAC1B,OAAO,IAAI;IACb;IACAyB,IAAI,CAACY,KAAK,CAACJ,YAAY,CAAC;;IAExB;IACA,IAAIhC,iBAAiB,EAAE;MACrB,IAAIsC,QAAQ,GAAGd,IAAI,CAACe,qBAAqB,CAAC,CAAC;MAC3CvC,iBAAiB,CAACwC,KAAK,CAACC,IAAI,GAAG,EAAE,CAACC,MAAM,CAACJ,QAAQ,CAACK,CAAC,GAAGzB,MAAM,CAAC0B,OAAO,EAAE,IAAI,CAAC;MAC3E5C,iBAAiB,CAACwC,KAAK,CAACK,GAAG,GAAG,EAAE,CAACH,MAAM,CAACJ,QAAQ,CAACQ,CAAC,GAAG5B,MAAM,CAAC6B,OAAO,EAAE,IAAI,CAAC;MAC1E/C,iBAAiB,CAACwC,KAAK,CAACQ,KAAK,GAAG,EAAE,CAACN,MAAM,CAACJ,QAAQ,CAACU,KAAK,EAAE,IAAI,CAAC;MAC/DhD,iBAAiB,CAACwC,KAAK,CAACS,MAAM,GAAG,EAAE,CAACP,MAAM,CAACJ,QAAQ,CAACW,MAAM,EAAE,IAAI,CAAC;IACnE;IACAlD,kBAAkB,GAAG,KAAK;IAC1BsC,YAAY,CAACb,IAAI,EAAEC,YAAY,CAAC;IAChC,OAAO,IAAI;EACb;EACA,SAASY,YAAYA,CAACb,IAAI,EAAEC,YAAY,EAAE;IACxC,IAAI,CAACA,YAAY,IAAI,CAACA,YAAY,CAACf,MAAM,EAAE;MACzCe,YAAY,GAAG,CAAC,CAAC,EAAExC,UAAU,CAACiE,oBAAoB,EAAE1B,IAAI,CAAC;IAC3D;IACA,IAAI2B,WAAW,GAAG,CAAC,CAAC,EAAExE,KAAK,CAAC,SAAS,CAAC,EAAE8C,YAAY,CAAC;IACrD,IAAI0B,WAAW,EAAE;MACf,CAAC,CAAC,EAAElE,UAAU,CAAC6C,8BAA8B,EAAEN,IAAI,EAAEC,YAAY,CAAC;MAClE,CAAC,CAAC,EAAExC,UAAU,CAACmE,gBAAgB,EAAED,WAAW,CAAC;IAC/C;IACA,IAAIE,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzCC,kBAAkB,CAAChC,IAAI,CAAC;IAC1B;EACF;EACA,SAASiC,YAAYA,CAAA,EAAG;IACtB,IAAIC,eAAe,GAAG,CAAC,CAAC,EAAEzE,UAAU,CAAC0E,gBAAgB,EAAE,CAAC;IACxD,IAAIC,IAAI;IACR,IAAIF,eAAe,EAAE;MACnB,IAAIG,QAAQ,GAAG,CAAC,CAAC,EAAE3E,QAAQ,CAAC4E,sBAAsB,EAAE,CAAC;;MAErD;MACAF,IAAI,GAAG,CAAC,CAAC,EAAE3E,UAAU,CAACiE,oBAAoB,EAAE,CAAC,CAAC,EAAEjE,UAAU,CAAC8E,gBAAgB,EAAEL,eAAe,CAAC,CAAC,CAACM,OAAO,CAAC,CAAC;;MAExG;MACA;MACA,IAAIC,kBAAkB,GAAG,CAAC,CAAC,EAAEhF,UAAU,CAACiF,8BAA8B,EAAER,eAAe,CAAC;MACxF,OAAO,CAAC,CAAC,EAAEzE,UAAU,CAACkF,WAAW,EAAEF,kBAAkB,CAAC,EAAE;QACtD,IAAIG,mBAAmB,GAAG,CAAC,CAAC,EAAEnF,UAAU,CAACoF,kBAAkB,EAAEJ,kBAAkB,CAAC;QAChFA,kBAAkB,GAAGG,mBAAmB,CAACH,kBAAkB;MAC7D;MACA,IAAIK,iBAAiB,GAAG,CAAC,CAAC,EAAErF,UAAU,CAAC8E,gBAAgB,EAAEL,eAAe,CAAC;MACzE,IAAI,CAACO,kBAAkB,IAAIK,iBAAiB,CAAC/B,qBAAqB,IAAI0B,kBAAkB,CAAC1B,qBAAqB,IAAI,CAAC,CAAC,CAAC,EAAEvD,MAAM,CAACuF,QAAQ,EAAED,iBAAiB,CAAC/B,qBAAqB,CAAC,CAAC,EAAE0B,kBAAkB,CAAC1B,qBAAqB,CAAC,CAAC,CAAC,EAAE;QAC9N0B,kBAAkB,GAAG,CAAC,CAAC,EAAEhF,UAAU,CAACoF,kBAAkB,EAAEX,eAAe,CAAC,CAACc,QAAQ,IAAI,CAAC,CAAC,EAAErF,OAAO,CAACsF,4BAA4B,EAAEZ,QAAQ,EAAEH,eAAe,CAAC;MAC3J;MACA,IAAIO,kBAAkB,EAAE;QACtBL,IAAI,CAACc,OAAO,CAACT,kBAAkB,CAAC;MAClC;IACF,CAAC,MAAM;MACLL,IAAI,GAAG,CAAC3E,UAAU,CAAC0F,eAAe,CAAC;IACrC;;IAEA;IACA;IACA,OAAOf,IAAI,CAACgB,MAAM,CAAC,UAAUC,OAAO,EAAEC,MAAM,EAAE;MAC5C,OAAOD,OAAO,IAAIxG,SAAS,CAAC+D,KAAK,CAAC0C,MAAM,CAAC;IAC3C,CAAC,EAAE,KAAK,CAAC;EACX;;EAEA;EACA,SAAStB,kBAAkBA,CAAChC,IAAI,EAAE;IAChC,IAAIuD,UAAU,GAAG,CAAC,IAAI,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM,CAAC;MAC9CC,aAAa,GAAGnG,UAAU,CAACoG,cAAc,GAAG,QAAQ;;IAEtD;IACAF,UAAU,CAACG,OAAO,CAAC,UAAUC,GAAG,EAAE;MAChC,IAAIC,SAAS,GAAGJ,aAAa,GAAGG,GAAG;QACjCE,SAAS,GAAG,CAAC,CAAC,EAAErG,MAAM,CAACsG,aAAa,EAAE,GAAG,GAAGF,SAAS,CAAC;MACxD,IAAIC,SAAS,IAAIA,SAAS,CAAC3E,MAAM,KAAK,CAAC,EAAE;QACvC2E,SAAS,CAACH,OAAO,CAAC,UAAUK,QAAQ,EAAE;UACpC,OAAOA,QAAQ,CAACC,SAAS,CAACC,MAAM,CAACL,SAAS,CAAC;QAC7C,CAAC,CAAC;MACJ;IACF,CAAC,CAAC;;IAEF;IACAL,UAAU,CAACG,OAAO,CAAC,UAAUC,GAAG,EAAE;MAChC,IAAIO,QAAQ,GAAG,CAAC,CAAC,EAAEvG,OAAO,CAACwG,+BAA+B,EAAER,GAAG,EAAE3D,IAAI,CAAC;MACtE,IAAIkE,QAAQ,EAAE;QACZA,QAAQ,CAACF,SAAS,CAACI,GAAG,CAACZ,aAAa,GAAGG,GAAG,CAAC;MAC7C;IACF,CAAC,CAAC;EACJ;EACA,SAASU,iBAAiBA,CAACC,SAAS,EAAEjC,QAAQ,EAAE;IAC9C,IAAIV,WAAW,GAAG9E,SAAS,CAAC0H,kBAAkB,CAAC,CAAC;IAChD,IAAInC,IAAI,GAAG,CAAC,CAAC,EAAEzE,OAAO,CAAC6G,gCAAgC,EAAEF,SAAS,EAAEjC,QAAQ,EAAEV,WAAW,CAAC;IAC1F,IAAIS,IAAI,EAAE;MACR,CAAC,CAAC,EAAE3E,UAAU,CAACgH,0BAA0B,EAAE9C,WAAW,EAAE2C,SAAS,EAAElC,IAAI,EAAE,CAAC,CAAC,EAAE3E,UAAU,CAACiF,8BAA8B,EAAEf,WAAW,CAAC,CAAC;MACrI,OAAO5B,YAAY,CAACqC,IAAI,EAAE,CAAC,CAAC,EAAE3E,UAAU,CAACiE,oBAAoB,EAAEU,IAAI,CAAC,CAAC;IACvE;IACA,OAAO,KAAK;EACd;EACA,SAASsC,QAAQA,CAACJ,SAAS,EAAE/D,qBAAqB,EAAEoE,mBAAmB,EAAE;IACvE,IAAIvC,IAAI,GAAG,CAAC,CAAC,EAAEzE,OAAO,CAACwG,+BAA+B,EAAEG,SAAS,EAAE/D,qBAAqB,CAAC;IACzF,IAAI6B,IAAI,EAAE;MACR,IAAIwC,kBAAkB,GAAG,CAAC,CAAC,EAAEzH,KAAK,CAAC,SAAS,CAAC,EAAEwH,mBAAmB,CAAC;MACnE,IAAIE,gBAAgB,GAAG,CAAC,CAAC,EAAEpH,UAAU,CAACiE,oBAAoB,EAAEU,IAAI,CAAC;;MAEjE;MACA;MACA,IAAI3D,YAAY,IAAIoG,gBAAgB,CAACC,OAAO,CAACF,kBAAkB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,EAAEnH,UAAU,CAACsH,uBAAuB,EAAEH,kBAAkB,CAAC,EAAE;QACpI,OAAO,KAAK;MACd;MACA,CAAC,CAAC,EAAEnH,UAAU,CAACuH,oBAAoB,EAAEV,SAAS,EAAE/D,qBAAqB,EAAEoE,mBAAmB,EAAEvC,IAAI,EAAEyC,gBAAgB,CAAC;MACnH,CAAC,CAAC,EAAEpH,UAAU,CAACgH,0BAA0B,EAAEG,kBAAkB,EAAEN,SAAS,EAAElC,IAAI,EAAE7B,qBAAqB,CAAC;MACtG,IAAI8C,OAAO,GAAGtD,YAAY,CAACqC,IAAI,EAAEyC,gBAAgB,CAAC;MAClD,CAAC,CAAC,EAAEpH,UAAU,CAACwH,oBAAoB,EAAEX,SAAS,EAAE/D,qBAAqB,EAAEoE,mBAAmB,EAAEvC,IAAI,EAAEyC,gBAAgB,CAAC;MACnH,OAAOxB,OAAO;IAChB;IACA,CAAC,CAAC,EAAE5F,UAAU,CAACyH,wBAAwB,EAAEZ,SAAS,EAAE/D,qBAAqB,EAAEoE,mBAAmB,CAAC;IAC/F,OAAO,KAAK;EACd;EACA,SAASQ,oBAAoBA,CAACtG,GAAG,EAAE;IACjC,IAAIyF,SAAS,GAAG1H,YAAY,CAACiC,GAAG,CAACT,OAAO,CAAC;IACzC,IAAI,CAACkG,SAAS,EAAE;IAChB,IAAI/D,qBAAqB,GAAGpB,WAAW,CAAC,CAAC;IACzC,IAAIwF,mBAAmB,GAAG,CAAC,CAAC,EAAElH,UAAU,CAACiE,oBAAoB,EAAEnB,qBAAqB,CAAC;IACrFmE,QAAQ,CAACJ,SAAS,EAAE/D,qBAAqB,EAAEoE,mBAAmB,CAAC;EACjE;EACA,SAASS,MAAMA,CAAA,EAAG;IAChB,IAAIC,OAAO,GAAGlG,WAAW,CAAC,CAAC;IAC3B,IAAIkG,OAAO,EAAE;MACXA,OAAO,CAACC,IAAI,CAAC,CAAC;IAChB;IACAzI,SAAS,CAACgD,cAAc,CAAC,KAAK,CAAC;IAC/BnB,kBAAkB,GAAG,IAAI;IACzBC,0BAA0B,GAAG,KAAK;EACpC;EACA,SAAS4G,qBAAqBA,CAACC,EAAE,EAAE;IACjC,IAAI,CAAC,CAAC,CAAC,EAAElI,MAAM,CAAC0B,QAAQ,EAAE,CAAC,IAAIwG,EAAE,IAAIA,EAAE,CAACC,MAAM,IAAID,EAAE,CAACC,MAAM,CAACC,IAAI,KAAK,OAAO,EAAE;MAC5EN,MAAM,CAAC,CAAC;IACV;EACF;EACA,SAASO,8BAA8BA,CAACC,IAAI,EAAE;IAC5C,IAAI9F,UAAU,GAAG8F,IAAI,CAAC9F,UAAU;IAChC,IAAI,CAACA,UAAU,EAAE;MACfN,sBAAsB,CAAC,CAAC;IAC1B;EACF;EACA,SAASqG,OAAOA,CAAA,EAAG;IACjB;IACA;IACA;IACA,IAAInH,kBAAkB,EAAE;MACtBc,sBAAsB,CAAC,CAAC;;MAExB;MACA;MACA;MACA,IAAIiD,kBAAkB,GAAG,CAAC,CAAC,EAAEhF,UAAU,CAACiF,8BAA8B,EAAEjF,UAAU,CAAC0F,eAAe,CAAC;MACnG,OAAO,CAAC,CAAC,EAAE1F,UAAU,CAACkF,WAAW,EAAEF,kBAAkB,CAAC,EAAE;QACtD,IAAIqD,oBAAoB,GAAG,CAAC,CAAC,EAAErI,UAAU,CAACoF,kBAAkB,EAAEJ,kBAAkB,CAAC;QACjFA,kBAAkB,GAAGqD,oBAAoB,CAACrD,kBAAkB;MAC9D;MACA,IAAI,CAAC5F,SAAS,CAAC+D,KAAK,CAAC6B,kBAAkB,CAAC,EAAE;QACxC;QACA;QACA5F,SAAS,CAAC+D,KAAK,CAAC,CAAC;MACnB;MACAlC,kBAAkB,GAAG,KAAK;IAC5B;EACF;EACA,SAASqH,OAAOA,CAAClH,GAAG,EAAE;IACpBF,0BAA0B,GAAG,KAAK;IAClC,IAAIP,OAAO,GAAGS,GAAG,CAACT,OAAO;IACzB,IAAIxB,YAAY,CAACwB,OAAO,CAAC,IAAIJ,OAAO,CAACI,OAAO,CAAC,EAAE;MAC7CC,oBAAoB,CAAC2H,KAAK,CAAC,CAAC;MAC5BvH,YAAY,GAAG,KAAK;IACtB;EACF;EACA,SAASwH,iBAAiBA,CAAA,EAAG;IAC3B,IAAI,CAAC9G,WAAW,CAAC,CAAC,EAAE;MAClB8C,YAAY,CAAC,CAAC;IAChB;EACF;EACA,SAASiE,SAASA,CAACrH,GAAG,EAAE;IACtB,IAAIE,uBAAuB,CAAC,CAAC,EAAE;MAC7B,CAAC,CAAC,EAAErB,QAAQ,CAACyI,aAAa,EAAEtH,GAAG,CAACT,OAAO,CAAC;MACxC;IACF;IACA,IAAIA,OAAO,GAAGS,GAAG,CAACT,OAAO;IACzB,IAAIkG,SAAS,GAAG1H,YAAY,CAACwB,OAAO,CAAC;IACrC,IAAIgI,cAAc,GAAG,CAAC,CAAC,EAAE1I,QAAQ,CAACyI,aAAa,EAAE/H,OAAO,EAAE6H,iBAAiB,CAAC;IAC5E,IAAIG,cAAc,IAAI,EAAE9B,SAAS,IAAItG,OAAO,CAACI,OAAO,CAAC,CAAC,EAAE;MACtD;IACF;IACA,IAAI,CAAC,CAAC,CAAC,EAAEd,MAAM,CAAC0B,QAAQ,EAAE,CAAC,IAAI,CAACL,0BAA0B,EAAE;MAC1D,IAAIQ,WAAW,CAAC,CAAC,EAAE;QACjBd,oBAAoB,CAACgI,UAAU,CAACxH,GAAG,EAAEsG,oBAAoB,CAAC;MAC5D,CAAC,MAAM,IAAI,CAACd,iBAAiB,CAACC,SAAS,EAAE,CAAC,CAAC,EAAE5G,QAAQ,CAAC4E,sBAAsB,EAAE,CAAC,CAAC,EAAE;QAChFL,YAAY,CAAC,CAAC;MAChB;MACAxD,YAAY,GAAG,IAAI;IACrB;IACA,IAAI6F,SAAS,EAAE;MACb1F,cAAc,CAACC,GAAG,CAAC;IACrB;EACF;EACA,SAASyH,WAAWA,CAACC,KAAK,EAAE;IAC1B,IAAIjD,MAAM,GAAGiD,KAAK,CAACjD,MAAM;MACvBkD,OAAO,GAAGD,KAAK,CAACC,OAAO;MACvBC,OAAO,GAAGF,KAAK,CAACE,OAAO;IACzB,IAAI1H,uBAAuB,CAAC,CAAC,EAAE;MAC7B,CAAC,CAAC,EAAErB,QAAQ,CAACgJ,iBAAiB,EAAE,IAAI,EAAEpD,MAAM,EAAEkD,OAAO,EAAEC,OAAO,CAAC;MAC/D;IACF;IACA,IAAIpB,OAAO,GAAGlG,WAAW,CAAC,CAAC;IAC3B,IAAIwH,MAAM,GAAG,CAAC,CAAC,EAAEjJ,QAAQ,CAACgJ,iBAAiB,EAAErB,OAAO,EAAE/B,MAAM,EAAEkD,OAAO,EAAEC,OAAO,CAAC;IAC/E,IAAIE,MAAM,EAAE;MACV,IAAIlI,YAAY,EAAE;QAChBE,0BAA0B,GAAG,IAAI;MACnC;MACA,IAAIyD,IAAI,GAAG,CAAC,CAAC,EAAEzE,OAAO,CAACiJ,kBAAkB,EAAEtD,MAAM,CAAC;;MAElD;MACA,IAAIlB,IAAI,KAAKiD,OAAO,EAAE;QACpB,IAAIjD,IAAI,EAAE;UACRrC,YAAY,CAACqC,IAAI,EAAE,CAAC,CAAC,EAAE3E,UAAU,CAACiE,oBAAoB,EAAEU,IAAI,CAAC,EAAE,IAAI,CAAC;UACpE,OAAO,IAAI;QACb,CAAC,MAAM,IAAIiD,OAAO,EAAE;UAClBA,OAAO,CAACC,IAAI,CAAC,CAAC;UACd,CAAC,CAAC,EAAE7H,UAAU,CAACoJ,0BAA0B,EAAExB,OAAO,EAAE/B,MAAM,CAAC;QAC7D;MACF;IACF;EACF;EACA,SAASwD,WAAWA,CAACjI,GAAG,EAAE;IACxB,IAAIE,uBAAuB,CAAC,CAAC,EAAE;IAC/B,IAAIuE,MAAM,GAAGzE,GAAG,CAACyE,MAAM;IACvB,IAAI,CAAC,CAAC,EAAE5F,QAAQ,CAAC0C,cAAc,EAAE,CAAC,IAAI,CAAC,CAAC,EAAE1C,QAAQ,CAACqJ,eAAe,EAAElI,GAAG,CAAC2H,OAAO,EAAE3H,GAAG,CAAC4H,OAAO,CAAC,EAAE;MAC7F,IAAIrE,IAAI,GAAG,CAAC,CAAC,EAAEzE,OAAO,CAACiJ,kBAAkB,EAAEtD,MAAM,CAAC,CAAC,CAAC;;MAEpD,IAAIlB,IAAI,IAAIA,IAAI,KAAKjD,WAAW,CAAC,CAAC,EAAE;QAClCY,YAAY,CAACqC,IAAI,EAAE,CAAC,CAAC,EAAE3E,UAAU,CAACiE,oBAAoB,EAAEU,IAAI,CAAC,EAAE,IAAI,CAAC;QACpE,OAAO,IAAI;MACb;MACAxD,cAAc,CAACC,GAAG,CAAC;IACrB;EACF;EACA,SAASmI,UAAUA,CAACnI,GAAG,EAAE;IACvB,IAAIwG,OAAO,GAAGlG,WAAW,CAAC,CAAC;IAC3B,IAAIkG,OAAO,IAAI,CAACA,OAAO,CAACtC,QAAQ,CAAClE,GAAG,CAACyE,MAAM,CAAC,EAAE;MAC5C+B,OAAO,CAACC,IAAI,CAAC,CAAC;IAChB;EACF;;EAEA;AACF;AACA;EACE,IAAI5I,OAAO,GAAG,iCAAiC;IAC7C;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACIuK,UAAU,EAAE,SAASA,UAAUA,CAACC,iBAAiB,EAAE;MACjD,IAAI,CAAC5I,YAAY,EAAE;QACjB,IAAI6I,oBAAoB;QACxBzH,MAAM,CAAC0H,gBAAgB,CAAC,MAAM,EAAEhC,MAAM,CAAC;QACvC1F,MAAM,CAAC0H,gBAAgB,CAAC,OAAO,EAAEvB,OAAO,CAAC;QACzCnG,MAAM,CAAC0H,gBAAgB,CAAC,SAAS,EAAElB,SAAS,CAAC;QAC7CxG,MAAM,CAAC0H,gBAAgB,CAAC,OAAO,EAAErB,OAAO,CAAC;QACzCrG,MAAM,CAAC0H,gBAAgB,CAAC,WAAW,EAAEN,WAAW,CAAC;QACjDpH,MAAM,CAAC0H,gBAAgB,CAAC,WAAW,EAAEd,WAAW,CAAC;QACjD,IAAIrJ,SAAS,CAAC,SAAS,CAAC,CAACoK,KAAK,EAAE;UAC9B3H,MAAM,CAAC0H,gBAAgB,CAAC,UAAU,EAAEJ,UAAU,CAAC;QACjD;QACA,IAAI/J,SAAS,CAAC,SAAS,CAAC,CAACqK,KAAK,EAAE;UAC9B5H,MAAM,CAAC2B,GAAG,CAAC/B,QAAQ,CAAC8H,gBAAgB,CAAC,YAAY,EAAE7B,qBAAqB,CAAC;UACzE7F,MAAM,CAAC2B,GAAG,CAAC/B,QAAQ,CAAC8H,gBAAgB,CAAC,qBAAqB,EAAEzB,8BAA8B,CAAC;QAC7F;QACA,CAAC,CAAC,EAAElI,UAAU,CAACmE,gBAAgB,EAAEnE,UAAU,CAAC0F,eAAe,CAAC;QAC5D,CAAC,CAAC,EAAE1F,UAAU,CAAC8J,iBAAiB,EAAEL,iBAAiB,CAAC;QACpD,CAAC,CAAC,EAAEzJ,UAAU,CAAC+J,kBAAkB,EAAE/J,UAAU,CAAC0F,eAAe,CAAC;QAC9D;QACA,CAAC,CAAC,EAAEzF,QAAQ,CAACmC,cAAc,EAAE,KAAK,CAAC;QACnCL,sBAAsB,CAAC,CAAC;;QAExB;QACA,IAAI,CAAC2H,oBAAoB,GAAG,CAAC,CAAC,EAAE1J,UAAU,CAACoF,kBAAkB,EAAE,wBAAwB,CAAC,MAAM,IAAI,IAAIsE,oBAAoB,KAAK,KAAK,CAAC,IAAIA,oBAAoB,CAACM,uBAAuB,EAAE;UACrLjJ,iBAAiB,GAAGc,QAAQ,CAACoI,aAAa,CAAC,qBAAqB,CAAC;QACnE;QACApJ,YAAY,GAAG,IAAI;MACrB;IACF,CAAC;IACD;AACJ;AACA;AACA;AACA;IACIqJ,SAAS,EAAE,SAASA,SAASA,CAAA,EAAG;MAC9BjI,MAAM,CAACkI,mBAAmB,CAAC,MAAM,EAAExC,MAAM,CAAC;MAC1C1F,MAAM,CAACkI,mBAAmB,CAAC,OAAO,EAAE/B,OAAO,CAAC;MAC5CnG,MAAM,CAACkI,mBAAmB,CAAC,SAAS,EAAE1B,SAAS,CAAC;MAChDxG,MAAM,CAACkI,mBAAmB,CAAC,OAAO,EAAE7B,OAAO,CAAC;MAC5CrG,MAAM,CAACkI,mBAAmB,CAAC,WAAW,EAAEd,WAAW,CAAC;MACpDpH,MAAM,CAACkI,mBAAmB,CAAC,WAAW,EAAEtB,WAAW,CAAC;MACpD,IAAIrJ,SAAS,CAAC,SAAS,CAAC,CAACoK,KAAK,EAAE;QAC9B3H,MAAM,CAACkI,mBAAmB,CAAC,UAAU,EAAEZ,UAAU,CAAC;MACpD;MACA,IAAI/J,SAAS,CAAC,SAAS,CAAC,CAACqK,KAAK,EAAE;QAC9B5H,MAAM,CAAC2B,GAAG,CAAC/B,QAAQ,CAACsI,mBAAmB,CAAC,YAAY,EAAErC,qBAAqB,CAAC;QAC5E7F,MAAM,CAAC2B,GAAG,CAAC/B,QAAQ,CAACsI,mBAAmB,CAAC,qBAAqB,EAAEjC,8BAA8B,CAAC;MAChG;MACA9I,SAAS,CAACgL,KAAK,CAAC,CAAC;MACjBvJ,YAAY,GAAG,KAAK;IACtB,CAAC;IACD;AACJ;AACA;AACA;AACA;IACIuJ,KAAK,EAAE,SAASA,KAAKA,CAAA,EAAG;MACtB,CAAC,CAAC,EAAEpK,UAAU,CAACqK,mBAAmB,EAAE,CAAC;MACrC,CAAC,CAAC,EAAErK,UAAU,CAACsK,mBAAmB,EAAE,CAAC;MACrC,CAAC,CAAC,EAAEtK,UAAU,CAACmE,gBAAgB,EAAE,CAAC;MAClCrD,kBAAkB,GAAG,KAAK;IAC5B,CAAC;IACD;IACA;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIyJ,GAAG,EAAEvK,UAAU,CAAC+J,kBAAkB;IAClC;IACA;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIpD,GAAG,EAAE3G,UAAU,CAACwK,YAAY;IAC5BC,OAAO,EAAE,SAASA,OAAOA,CAACvG,WAAW,EAAE;MACrC,IAAI,CAACA,WAAW,IAAI,OAAOA,WAAW,KAAK,QAAQ,EAAE;QACnD,MAAM,IAAIwG,KAAK,CAAC,kCAAkC,CAAC;MACrD;MACA,CAAC,CAAC,EAAE1K,UAAU,CAAC2K,gBAAgB,EAAEzG,WAAW,CAAC;IAC/C,CAAC;IACD;AACJ;AACA;AACA;AACA;AACA;AACA;IACIsC,MAAM,EAAE,SAASA,MAAMA,CAACtC,WAAW,EAAE;MACnC,IAAI,CAACA,WAAW,IAAI,OAAOA,WAAW,KAAK,QAAQ,EAAE;QACnD,MAAM,IAAIwG,KAAK,CAAC,kCAAkC,CAAC;MACrD;MACA,IAAI,CAAC,CAAC,EAAE1K,UAAU,CAACoF,kBAAkB,EAAElB,WAAW,CAAC,EAAE;QACnD,CAAC,CAAC,EAAElE,UAAU,CAAC4K,eAAe,EAAE1G,WAAW,CAAC;QAC5C,IAAI,CAAC,CAAC,EAAElE,UAAU,CAAC0E,gBAAgB,EAAE,CAAC,KAAKR,WAAW,EAAE;UACtD9E,SAAS,CAACyL,kBAAkB,CAAC,IAAI,CAAC;QACpC;QACA,OAAO,IAAI;MACb;MACA,OAAO,KAAK;IACd,CAAC;IACD;AACJ;AACA;AACA;AACA;AACA;AACA;IACIC,eAAe,EAAE,SAASA,eAAeA,CAAC5G,WAAW,EAAE;MACrD,IAAI,CAAC,CAAC,EAAElE,UAAU,CAACkF,WAAW,EAAEhB,WAAW,CAAC,EAAE;QAC5C,CAAC,CAAC,EAAElE,UAAU,CAAC+J,kBAAkB,EAAE7F,WAAW,EAAE;UAC9C6G,gBAAgB,EAAE;QACpB,CAAC,CAAC;QACF,OAAO,IAAI;MACb;MACA,OAAO,KAAK;IACd,CAAC;IACD;AACJ;AACA;AACA;AACA;AACA;AACA;IACIC,cAAc,EAAE,SAASA,cAAcA,CAAC9G,WAAW,EAAE;MACnD,IAAI,CAAC,CAAC,EAAElE,UAAU,CAACkF,WAAW,EAAEhB,WAAW,CAAC,EAAE;QAC5C,CAAC,CAAC,EAAElE,UAAU,CAAC+J,kBAAkB,EAAE7F,WAAW,EAAE;UAC9C6G,gBAAgB,EAAE;QACpB,CAAC,CAAC;QACF,OAAO,IAAI;MACb;MACA,OAAO,KAAK;IACd,CAAC;IACD;AACJ;AACA;AACA;AACA;AACA;AACA;IACIE,KAAK,EAAEpL,MAAM,CAACoL,KAAK;IACnB;AACJ;AACA;AACA;AACA;AACA;AACA;IACIC,MAAM,EAAErL,MAAM,CAACqL,MAAM;IACrB;IACA;IACA;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI/H,KAAK,EAAE,SAASA,KAAKA,CAACZ,IAAI,EAAE;MAC1B,IAAI4I,eAAe,GAAGC,SAAS,CAAC3J,MAAM,GAAG,CAAC,IAAI2J,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;MAC5F,IAAIvF,MAAM,GAAGtD,IAAI;MACjB,IAAI+I,cAAc,GAAG,KAAK;MAC1B,IAAIC,oBAAoB,GAAG,IAAI;MAC/B,IAAI,CAAChJ,IAAI,EAAE;QACTsD,MAAM,GAAG,CAAC,CAAC,EAAE3F,OAAO,CAACsL,oBAAoB,EAAE,CAAC;MAC9C,CAAC,MAAM,IAAI,OAAOjJ,IAAI,KAAK,QAAQ,EAAE;QACnC,IAAI,CAAC,CAAC,EAAEvC,UAAU,CAACoF,kBAAkB,EAAE7C,IAAI,CAAC,EAAE;UAC5CsD,MAAM,GAAG,CAAC,CAAC,EAAE3F,OAAO,CAACsL,oBAAoB,EAAEjJ,IAAI,EAAE4I,eAAe,CAACM,OAAO,CAAC;UACzEH,cAAc,GAAG,IAAI;UACrBC,oBAAoB,GAAG,CAAC,CAAC,EAAEvL,UAAU,CAAC8E,gBAAgB,EAAEvC,IAAI,CAAC;QAC/D,CAAC,MAAM,IAAI,YAAY,CAACmJ,IAAI,CAACnJ,IAAI,CAAC,EAAE;UAClC;UACAsD,MAAM,GAAG,CAAC,CAAC,EAAE3F,OAAO,CAACyL,mBAAmB,EAAE,qBAAqB,CAAClI,MAAM,CAAClB,IAAI,EAAE,GAAG,CAAC,CAAC;QACpF,CAAC,MAAM;UACLsD,MAAM,GAAG,CAAC,CAAC,EAAE3F,OAAO,CAACyL,mBAAmB,EAAEpJ,IAAI,CAAC;QACjD;MACF,CAAC,MAAM,IAAI,CAAC,CAAC,EAAEvC,UAAU,CAACkF,WAAW,EAAE3C,IAAI,CAAC,EAAE;QAC5CsD,MAAM,GAAG,CAAC,CAAC,EAAE3F,OAAO,CAACsL,oBAAoB,EAAE,CAAC,CAAC,EAAExL,UAAU,CAAC4L,cAAc,EAAErJ,IAAI,CAAC,EAAE4I,eAAe,CAACM,OAAO,CAAC;QACzGF,oBAAoB,GAAGhJ,IAAI;MAC7B;MACA,IAAI6E,gBAAgB,GAAG,CAAC,CAAC,EAAEpH,UAAU,CAACiE,oBAAoB,EAAE4B,MAAM,CAAC;MACnE,IAAIgG,eAAe,GAAG,CAAC,CAAC,EAAEnM,KAAK,CAAC,SAAS,CAAC,EAAE0H,gBAAgB,CAAC;MAC7D,IAAI,CAAC,CAAC,EAAEpH,UAAU,CAAC8L,WAAW,EAAEjG,MAAM,EAAEgG,eAAe,EAAE,IAAI,CAAC,EAAE;QAC9D,IAAIjG,OAAO,GAAGtD,YAAY,CAACuD,MAAM,EAAEuB,gBAAgB,CAAC;QACpD,IAAI,CAACxB,OAAO,IAAI0F,cAAc,EAAE;UAC9B,CAAC,CAAC,EAAEtL,UAAU,CAACmE,gBAAgB,EAAE5B,IAAI,CAAC;QACxC;QACA,OAAOqD,OAAO;MAChB,CAAC,MAAM,IAAI0F,cAAc,EAAE;QACzB;QACA;QACA,CAAC,CAAC,EAAEtL,UAAU,CAACmE,gBAAgB,EAAE5B,IAAI,CAAC;MACxC;MACA,IAAI4I,eAAe,CAACY,gBAAgB,IAAIR,oBAAoB,EAAE;QAC5D,IAAIS,cAAc,GAAG,CAAC,CAAC,EAAEhM,UAAU,CAACiE,oBAAoB,EAAEsH,oBAAoB,CAACU,aAAa,CAAC,CAACC,GAAG,CAAC,CAAC;QACnG,IAAIF,cAAc,EAAE;UAClB,OAAO,IAAI,CAAC7I,KAAK,CAAC6I,cAAc,EAAEb,eAAe,CAAC;QACpD;MACF;MACA,OAAO,KAAK;IACd,CAAC;IACD;IACA;IACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIgB,IAAI,EAAE,SAASA,IAAIA,CAACtF,SAAS,EAAEuF,QAAQ,EAAE;MACvCvF,SAAS,GAAGA,SAAS,CAACwF,WAAW,CAAC,CAAC;MACnC,IAAIxF,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,MAAM,IAAIA,SAAS,KAAK,MAAM,IAAIA,SAAS,KAAK,OAAO,EAAE;QAC/F,OAAO,KAAK;MACd;MACA,IAAItE,IAAI,GAAG6J,QAAQ,GAAG,CAAC,CAAC,EAAErM,MAAM,CAACsG,aAAa,EAAE+F,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAG1K,WAAW,CAAC,CAAC;MAC5E,IAAI,CAACa,IAAI,EAAE;QACT,OAAO,KAAK;MACd;MACA,IAAIC,YAAY,GAAG,CAAC,CAAC,EAAExC,UAAU,CAACiE,oBAAoB,EAAE1B,IAAI,CAAC;MAC7D,IAAI,CAACC,YAAY,CAACf,MAAM,EAAE;QACxB,OAAO,KAAK;MACd;MACA,OAAOwF,QAAQ,CAACJ,SAAS,EAAEtE,IAAI,EAAEC,YAAY,CAAC;IAChD,CAAC;IACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI8H,mBAAmB,EAAEtK,UAAU,CAACsK,mBAAmB;IACnD;AACJ;AACA;AACA;AACA;AACA;IACIxD,kBAAkB,EAAE,SAASA,kBAAkBA,CAAA,EAAG;MAChD,OAAO,CAAC,CAAC,EAAE9G,UAAU,CAAC0E,gBAAgB,EAAE,CAAC,IAAI1E,UAAU,CAAC0F,eAAe;IACzE,CAAC;IACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACImF,kBAAkB,EAAE,SAASA,kBAAkBA,CAAC3G,WAAW,EAAE;MAC3D,IAAI,CAAC,CAAC,EAAElE,UAAU,CAACsM,oBAAoB,EAAEpI,WAAW,CAAC,EAAE;QACrD,CAAC,CAAC,EAAElE,UAAU,CAACmE,gBAAgB,EAAED,WAAW,IAAIlE,UAAU,CAAC0F,eAAe,CAAC;MAC7E;IACF,CAAC;IACD;AACJ;AACA;AACA;AACA;AACA;AACA;IACI/C,cAAc,EAAE1C,QAAQ,CAAC0C,cAAc;IACvC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACIP,cAAc,EAAEnC,QAAQ,CAACmC,cAAc;IACvC;AACJ;AACA;AACA;AACA;AACA;AACA;IACImK,OAAO,EAAE,SAASA,OAAOA,CAAChK,IAAI,EAAE;MAC9B,IAAI,CAACA,IAAI,EAAE;QACT,OAAO,KAAK;MACd;MACA,OAAO,CAAC,CAAC,EAAExC,MAAM,CAACyM,aAAa,EAAE,2CAA2C,GAAG5M,UAAU,CAACoG,cAAc,EAAEzD,IAAI,CAAC;IACjH,CAAC;IACD;AACJ;AACA;AACA;AACA;AACA;AACA;IACIhB,QAAQ,EAAE1B,MAAM,CAAC0B,QAAQ;IACzB;AACJ;AACA;AACA;AACA;AACA;AACA;IACIkL,WAAW,EAAE,SAASA,WAAWA,CAAClK,IAAI,EAAE;MACtC,IAAI,CAACA,IAAI,EAAE;QACT,OAAO,KAAK;MACd;MACA,OAAO,CAAC,CAAC,EAAErC,OAAO,CAACwM,WAAW,EAAEnK,IAAI,CAAC;IACvC,CAAC;IACD;AACJ;AACA;AACA;AACA;AACA;IACIoK,UAAU,EAAE,SAASA,UAAUA,CAAA,EAAG;MAChC,OAAOjL,WAAW,CAAC,CAAC;IACtB,CAAC;IACD;AACJ;AACA;AACA;AACA;AACA;AACA;IACIkL,uBAAuB,EAAE,SAASA,uBAAuBA,CAAC1I,WAAW,EAAE;MACrE,IAAI,CAACA,WAAW,IAAI,OAAOA,WAAW,KAAK,QAAQ,EAAE;QACnD,MAAM,IAAIwG,KAAK,CAAC,kCAAkC,CAAC;MACrD;MACA,OAAO,CAAC,CAAC,EAAE1K,UAAU,CAAC4M,uBAAuB,EAAE1I,WAAW,CAAC;IAC7D,CAAC;IACD;AACJ;AACA;AACA;AACA;AACA;AACA;IACI2I,kBAAkB,EAAEjG;EACtB,CAAC;EACD,OAAO3H,OAAO;AAChB,CAAC,CAAC,CAAC;AACHA,OAAO,CAACG,SAAS,GAAGA,SAAS;AAC7B,IAAI0N,QAAQ,GAAG1N,SAAS;AACxBH,OAAO,CAAC,SAAS,CAAC,GAAG6N,QAAQ"},"metadata":{},"sourceType":"module","externalDependencies":[]}