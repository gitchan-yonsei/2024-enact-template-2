{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stopImmediate = exports.stop = exports.returnsTrue = exports.preventDefault = exports.oneOf = exports.not = exports.log = exports.handle = exports.forwardWithPrevent = exports.forwardCustomWithPrevent = exports.forwardCustom = exports.forward = exports.forProp = exports.forKeyCode = exports.forKey = exports.forEventProp = exports[\"default\"] = exports.callOnEvent = exports.call = exports.adaptEvent = void 0;\nvar _cond = _interopRequireDefault(require(\"ramda/src/cond\"));\nvar _curry = _interopRequireDefault(require(\"ramda/src/curry\"));\nvar _keymap = require(\"../keymap\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n/**\n * `core/handle` provides a set of utilities to support handling events for `kind()`s and\n * `React.Component`s. The default export, `handle()`, generates an event handler function from a\n * set of input functions. The input functions either process or filter the event. If an input\n * function returns `true`, `handle()` will continue processing the event by calling the next input\n * function in the chain. If it returns `false` (or any falsy value like `null` or `undefined`),\n * the event handling chain stops at that input function.\n *\n * Example:\n * ```\n * import {forKey, forward, handle, preventDefault} from '@enact/core/handle';\n *\n * // logEnter will contain a function that accepts an event, a props object, and a context object\n * const logEnter = handle(\n *   forward('onKeyDown'),  // forwards the event to the function passed in the onKeyDown prop\n *   forKey('enter'),       // if the event.keyCode maps to the enter key, allows event processing to continue\n *   preventDefault,        // calls event.preventDefault() to prevent the `keypress` event\n *   (ev, props) => {       // custom event handler -- in this case, logging some text\n *     // since it doesn't return `true`, no further input functions would be called after this one\n *     console.log('The Enter key was pressed down');\n *   }\n * ).finally(() => {\n * \t console.log('This will log at the end no matter what happens within the handler above')\n * });\n * ```\n *\n * `handle()` can also be bound to a component instance which allows it to access the instance\n * `props` and `context`. This allows you to write consistent event handlers for components created\n * either with `kind()` or ES6 classes without worrying about from where the props are sourced.\n *\n * Handlers can either be bound directly using the native `bind()` method or using the `bindAs()`\n * utility method that is appended to the handler.\n *\n * Example:\n * ```\n * import {forKey, forward, handle, preventDefault} from '@enact/core/handle';\n * import {Component} from 'react';\n *\n * class MyComponent extends Component {\n *   // bind handle() to the instance\n *   constructor () {\n *     super();\n *\n *     // logEnter will be bound to `this` and set as this.handleKeyDown\n *     //\n *     // Equivalent to the following with the advantage of set the function name to be displayed in\n *     // development tool call stacks\n *     //\n *     //   this.handleKeyDown = logEnter.bind(this)\n *     logEnter.bindAs(this, 'handleKeyDown');\n *   }\n *\n *   render () {\n *     return (\n *       <div onKeyDown={this.handleKeyDown} />\n *     );\n *   }\n * }\n * ```\n *\n * @module core/handle\n * @exports adaptEvent\n * @exports call\n * @exports callOnEvent\n * @exports forward\n * @exports forwardWithPrevent\n * @exports forEventProp\n * @exports forKey\n * @exports forKeyCode\n * @exports forProp\n * @exports handle\n * @exports log\n * @exports oneOf\n * @exports preventDefault\n * @exports returnsTrue\n * @exports stop\n * @exports stopImmediate\n */\n\n/**\n * The signature for event handlers\n *\n * @callback EventHandler\n * @memberof core/handle\n * @param {any} event\n */\n\n/**\n * The signature for event handling functions supported by `handle` and related functions\n *\n * @callback HandlerFunction\n * @memberof core/handle\n * @param {any} event\n * @param {Object<string, any>} props\n * @param {Object<string, any>} context\n */\n\n/**\n * The signature for {@link core/handle.adaptEvent} parameter `adapter`\n *\n * @callback EventAdapter\n * @memberof core/handle\n * @param {any} event\n * @param {Object<string, any>} props\n * @param {Object<string, any>} context\n * @returns {any}\n */\n\n// Accepts an array of handlers, sanitizes them, and returns a handler function\n// compose(allPass, map(makeSafeHandler));\nvar makeHandler = function makeHandler(handlers) {\n  // allowing shadowing here to provide a meaningful function name in dev tools\n  // eslint-disable-next-line no-shadow\n  return function handle() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    for (var i = 0; i < handlers.length; i++) {\n      var fn = handlers[i];\n      if (typeof fn !== 'function' || fn.apply(this, args)) {\n        continue;\n      }\n      return false;\n    }\n    return true;\n  };\n};\n\n// Loose check to determine if obj is component-ish if it has both props and context members\nvar hasPropsAndContext = function hasPropsAndContext(obj) {\n  return obj && Object.prototype.hasOwnProperty.call(obj, 'props') && Object.prototype.hasOwnProperty.call(obj, 'context');\n};\nvar named = function named(fn, name) {\n  if (process.env.NODE_ENV !== \"production\") {\n    try {\n      Object.defineProperty(fn, 'name', {\n        value: name,\n        writeable: false,\n        enumerable: false\n      });\n    } catch (err) {\n      // unable to set name of function\n    }\n  }\n  return fn;\n};\nvar bindAs = function bindAs(fn, obj, name) {\n  var namedFunction = name ? named(fn, name) : fn;\n  var bound = namedFunction.bind(obj);\n  if (name) {\n    obj[name] = bound;\n  }\n  return bound;\n};\nvar decorateHandleFunction = function decorateHandleFunction(fn) {\n  fn.named = function (name) {\n    return named(fn, name);\n  };\n  fn.bindAs = function (obj, name) {\n    return bindAs(fn, obj, name);\n  };\n  return fn;\n};\n\n/**\n * Allows generating event handlers by chaining input functions to filter or short-circuit the\n * handling flow. Any input function that returns a falsy value will stop the chain.\n *\n * The returned handler function has a `finally()` member that accepts a function and returns a new\n * handler function. The accepted function is called once the original handler completes regardless\n * of the returned value.\n *\n * @method   handle\n * @param    {...HandlerFunction}  handlers List of handlers to process the event.\n *\n * @returns  {EventHandler}\tA function that accepts an event which is dispatched to each of the\n *                          provided handlers.\n * @memberof core/handle\n * @public\n */\nvar handle = function handle() {\n  for (var _len2 = arguments.length, handlers = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    handlers[_key2] = arguments[_key2];\n  }\n  var h = makeHandler(handlers);\n\n  // In order to support binding either handle (handle.bind(this)) or a handler\n  // (a = handle(), a.bind(this)), we cache `this` here and use it as the fallback for props and\n  // context if fn() doesn't have its own `this`.\n  var _outer = this;\n  var fn = function prepareHandleArgs(ev, props, context) {\n    var caller = null;\n\n    // if handle() was bound to a class, use its props and context. otherwise, we accept\n    // incoming props/context as would be provided by computed/handlers from kind()\n    if (hasPropsAndContext(this)) {\n      caller = this;\n      props = this.props;\n      context = this.context;\n    } else if (hasPropsAndContext(_outer)) {\n      caller = _outer;\n      props = _outer.props;\n      context = _outer.context;\n    }\n    return h.call(caller, ev, props, context);\n  };\n  fn[\"finally\"] = function (cleanup) {\n    return decorateHandleFunction(function handleWithFinally(ev, props, context) {\n      var result = false;\n      if (hasPropsAndContext(this)) {\n        props = this.props;\n        context = this.context;\n      }\n      try {\n        result = fn.call(this, ev, props, context);\n      } finally {\n        cleanup.call(this, ev, props, context);\n      }\n      return result;\n    });\n  };\n  return decorateHandleFunction(fn);\n};\n\n/**\n * Calls the first handler whose condition passes. Each branch must be passed as an array with the\n * first element being the condition function and the second being the handler function. The same\n * arguments are passed to both the condition function and the handler function. The value returned\n * from the handler is returned.\n *\n * Example:\n * ```\n * const handler = oneOf(\n * \t[forKey('enter'), handleEnter],\n * \t[forKey('left'), handleLeft],\n * \t[forKey('right'), handleRight]\n * );\n * ```\n *\n * @method   oneOf\n * @param    {...[HandlerFunction, HandlerFunction]}  handlers List of conditions and handlers to process the event\n *\n * @returns  {HandlerFunction} A function that accepts an event which is dispatched to each of the\n *                             conditions and, if it passes, onto the provided handler.\n * @memberof core/handle\n * @public\n */\nexports.handle = handle;\nvar oneOf = handle.oneOf = function () {\n  for (var _len3 = arguments.length, handlers = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    handlers[_key3] = arguments[_key3];\n  }\n  return handle.call(this, (0, _cond[\"default\"])(handlers));\n};\n\n/**\n * A function that always returns `true`. Optionally accepts a `handler` function which is called\n * before returning `true`.\n *\n * Example:\n * ```\n * // Used to coerce an existing function into a handler\n * const coercedHandler = handle(\n *   returnsTrue(doesSomething),\n *   willAlwaysBeCalled\n * );\n *\n * // Used to emulate if/else blocks with `oneOf`\n * const ifElseHandler = oneOf(\n * \t[forKey('enter'), handleEnter],\n * \t[returnsTrue, handleOtherwise]\n * );\n * ```\n *\n * @method   returnsTrue\n * @param    {Function}  [handler]  Handler function called before returning `true`.\n *\n * @returns  {HandlerFunction}\t   A function that returns `true`\n * @memberof core/handle\n * @public\n */\nexports.oneOf = oneOf;\nvar returnsTrue = handle.returnsTrue = function (handler) {\n  if (handler && typeof handler === 'function') {\n    return named(function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      handler.apply(this, args);\n      return true;\n    }, 'returnsTrue');\n  }\n  return true;\n};\n\n/**\n * Calls a named function on the event and returns `true`.\n *\n * Example:\n * ```\n * import {callOnEvent, handle} from '@enact/core/handle';\n *\n * const callsCustomMethod = handle(\n *\tcallOnEvent('customMethod'),\n *\t(ev) => console.log('ev.customMethod() was called', ev)\n * );\n * ```\n *\n * @method   callOnEvent\n * @param    {String}     methodName  Name of the method to call on the event\n * @param    {Object}     ev          Event payload\n *\n * @returns  {true}                   Always returns `true`\n * @curried\n * @memberof core/handle\n * @private\n */\nexports.returnsTrue = returnsTrue;\nvar callOnEvent = handle.callOnEvent = (0, _curry[\"default\"])(function (methodName, ev) {\n  if (ev[methodName]) {\n    ev[methodName]();\n  } else if (ev.nativeEvent && ev.nativeEvent[methodName]) {\n    // In some cases (notably stopImmediatePropagation), React doesn't include a desired method\n    // on its proxy so we check the native event as well.\n    ev.nativeEvent[methodName]();\n  }\n  return true;\n});\n\n/**\n * Allows handling to continue if the value of `prop` on the event strictly equals `value`\n *\n * Example:\n * ```\n * import {forEventProp, handle} from '@enact/core/handle';\n *\n * const logWhenXEqualsZero = handle(\n *   forEventProp('x', 0),\n *   (ev) => console.log('ev.x was equal to zero', ev)\n * );\n * ```\n *\n * @method   forEventProp\n * @param    {String}\t   prop   Name of property on event\n * @param    {*}           value  Value of property\n * @param    {Object}      ev     Event payload\n *\n * @returns  {Boolean}            Returns `true` if `prop` on `event` strictly equals `value`\n * @curried\n * @memberof core/handle\n * @public\n */\nexports.callOnEvent = callOnEvent;\nvar forEventProp = handle.forEventProp = (0, _curry[\"default\"])(function (prop, value, ev) {\n  return ev[prop] === value;\n});\n\n/**\n * Forwards the event to a function at `name` on `props`. If the specified prop is `undefined` or\n * is not a function, it is ignored. The return value of the forwarded function is ignored and\n * `true` is always returned instead.\n *\n * Example:\n * ```\n * import {forward, handle} from '@enact/core/handle';\n *\n * const forwardAndLog = handle(\n *   forward('onClick'),\n *   (ev) => console.log('event forwarded to onClick from props', ev)\n * );\n * ```\n *\n * @method   forward\n * @param    {String}    name   Name of method on the `props`\n * @param    {Object}    ev     Event payload\n * @param    {Object}    props  Props object\n *\n * @returns  {true}             Always returns `true`\n * @curried\n * @memberof core/handle\n * @public\n */\nexports.forEventProp = forEventProp;\nvar forward = handle.forward = (0, _curry[\"default\"])(named(function (name, ev, props) {\n  var fn = props && props[name];\n  if (typeof fn === 'function') {\n    fn(ev);\n  }\n  return true;\n}, 'forward'));\n\n/**\n * Calls `event.preventDefault()` and returns `true`.\n *\n * Example:\n * ```\n * import {handle, preventDefault} from '@enact/core/handle';\n *\n * const preventAndLog = handle(\n *   preventDefault,\n *   (ev) => console.log('preventDefault called', ev)\n * );\n * ```\n *\n * @method   preventDefault\n * @param    {Object}        ev  Event payload\n *\n * @returns  {true}              Always returns `true`\n * @memberof core/handle\n * @public\n */\nexports.forward = forward;\nvar _preventDefault = handle.preventDefault = callOnEvent('preventDefault');\n\n/**\n * Forwards the event to a function at `name` on `props` with capability to prevent default\n * behavior. If the specified prop is `undefined` or is not a function, it is ignored. Returns\n * `false` when `event.preventDefault()` has been called in a handler.\n *\n * Example:\n * ```\n * import {forwardWithPrevent, handle} from '@enact/core/handle';\n *\n * const forwardPreventDefault = handle(\n *   forwardWithPrevent('onClick'),\n *   (ev) => console.log('default action', ev)\n * );\n * ```\n *\n * @method   forwardWithPrevent\n * @param    {String}    name   Name of method on the `props`\n * @param    {Object}    ev     Event payload\n * @param    {Object}    props  Props object\n *\n * @returns  {Boolean}          Returns `false` if default action is prevented\n * @curried\n * @memberof core/handle\n * @private\n */\nexports.preventDefault = _preventDefault;\nvar forwardWithPrevent = handle.forwardWithPrevent = (0, _curry[\"default\"])(named(function (name, ev, props) {\n  var prevented = false;\n  var wrappedEvent = Object.assign({}, ev, {\n    preventDefault: function preventDefault() {\n      prevented = true;\n      _preventDefault(ev);\n    }\n  });\n  forward(name, wrappedEvent, props);\n  return !prevented;\n}, 'forwardWithPrevent'));\n\n/**\n * Calls `event.stopPropagation()` and returns `true`\n *\n * Example:\n * ```\n * import {handle, stop} from '@enact/core/handle';\n *\n * const stopAndLog = handle(\n *   stop,\n *   (ev) => console.log('stopPropagation called', ev)\n * );\n * ```\n *\n * @method   stop\n * @param    {Object}   ev  Event payload\n *\n * @returns  {true}         Always returns `true`\n * @curried\n * @memberof core/handle\n * @public\n */\nexports.forwardWithPrevent = forwardWithPrevent;\nvar stop = handle.stop = named(callOnEvent('stopPropagation'), 'stop');\n\n/**\n * Calls `event.stopImmediatePropagation()` and returns `true`\n *\n * Example:\n * ```\n * import {handle, stopImmediate} from '@enact/core/handle';\n *\n * const stopImmediateAndLog = handle(\n *   stopImmediate,\n *   (ev) => console.log('stopImmediatePropagation called', ev)\n * );\n * ```\n *\n * @method   stopImmediate\n * @param    {Object}       ev  Event payload\n *\n * @returns  {true}             Always returns `true`\n * @curried\n * @memberof core/handle\n * @public\n */\nexports.stop = stop;\nvar stopImmediate = handle.stopImmediate = callOnEvent('stopImmediatePropagation');\n\n/**\n * Allows event handling to continue if `event.keyCode === value`.\n *\n * Example:\n * ```\n * import {forKeyCode, handle} from '@enact/core/handle';\n *\n * const logForEscapeKey = handle(\n *   forKeyCode(27),\n *   (ev) => console.log('Escape key pressed down', ev)\n * );\n * ```\n *\n * @method   forKeyCode\n * @param    {Number}    value  `keyCode` to test\n * @param    {Object}    ev     Event payload\n *\n * @returns  {Boolean}          Returns `true` if `event.keyCode` strictly equals `value`\n * @curried\n * @memberof core/handle\n * @public\n */\nexports.stopImmediate = stopImmediate;\nvar forKeyCode = handle.forKeyCode = forEventProp('keyCode');\n\n/**\n * Allows handling to continue if the event's keyCode is mapped to `name` within\n * {@link core/keymap}.\n *\n * Example:\n * ```\n * import {forKey, handle} from '@enact/core/handle';\n *\n * const logForEnterKey = handle(\n *   forKey('enter'),\n *   (ev) => console.log('Enter key pressed down', ev)\n * );\n * ```\n *\n * @see      {@link core/keymap}\n * @method   forKey\n * @param    {String}    name   Name from {@link core/keymap}\n * @param    {Object}    ev     Event payload\n *\n * @returns  {Boolean}          Returns `true` if `event.keyCode` is mapped to `name`\n * @curried\n * @memberof core/handle\n * @public\n */\nexports.forKeyCode = forKeyCode;\nvar forKey = handle.forKey = (0, _curry[\"default\"])(function (name, ev) {\n  return (0, _keymap.is)(name, ev.keyCode);\n});\n\n/**\n * Allows handling to continue if the value of `prop` on the props strictly equals `value`.\n *\n * Example:\n * ```\n * import {forProp, handle} from '@enact/core/handle';\n *\n * const logWhenChecked = handle(\n *   forProp('checked', true),\n *   (ev) => console.log('checked prop is true', ev)\n * );\n * ```\n *\n * @method   forProp\n * @param    {String}    prop   Name of property on props object\n * @param    {*}         value  Value of property\n * @param    {Object}    ev     Event payload\n * @param    {Object}    props  Props object\n *\n * @returns  {Boolean}          Returns `true` if the value of `props[prop]` strictly equals `value`\n * @curried\n * @memberof core/handle\n * @public\n */\nexports.forKey = forKey;\nvar forProp = handle.forProp = (0, _curry[\"default\"])(function (prop, value, ev, props) {\n  return props[prop] === value;\n});\n\n/**\n * Logs the event, props, and context optionally preceded by a custom message. Will only log in\n * development mode.\n *\n * Example:\n * ```\n * import {forProp, handle, log} from '@enact/core/handle';\n *\n * const logWhenChecked = handle(\n *   forProp('checked', true),\n *   log('checked props is true')\n * );\n * ```\n *\n * @method   log\n * @param    {String}     message  Custom message\n * @param    {Object}     ev       Event payload\n * @param    {...*}       [args]   Any args passed are logged\n *\n * @returns  {true}                Always returns `true`\n * @curried\n * @memberof core/handle\n * @public\n */\nexports.forProp = forProp;\nvar log = handle.log = (0, _curry[\"default\"])(function (message, ev) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var _console;\n    for (var _len5 = arguments.length, args = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n      args[_key5 - 2] = arguments[_key5];\n    }\n    // eslint-disable-next-line no-console\n    (_console = console).log.apply(_console, [message, ev].concat(args));\n  }\n  return true;\n});\n\n/**\n * Invokes a method by name on the component to which {@link core/handle.handle} is bound.\n *\n * If the methods exists on the object, it is called with the event, props, and context and its\n * return value is returned.\n *\n * If the method does not exist or handle isn't bound to an instance, it returns `false`.\n *\n * Example:\n * ```\n * import {call, handle, forProp} from '@enact/core/handle';\n *\n * const incrementIfEnabled = handle(\n *   forProp('disabled', false),\n *   call('increment')\n * );\n *\n * class Counter extends React.Component {\n *   constructor () {\n *     super();\n *\n *     this.handleIncrement = incrementIfEnabled.bind(this);\n *   }\n *\n *   render () {\n *     // ...\n *   }\n * }\n * ```\n *\n * @method   call\n * @param    {String}     method  Name of method\n *\n * @returns  {HandlerFunction}    Returns the value returned by `method`, or `false` if the method\n *                                does not exist\n * @memberof core/handle\n * @public\n */\nexports.log = log;\nvar call = function call(method) {\n  return named(function () {\n    if (this && this[method]) {\n      return this[method].apply(this, arguments);\n    }\n    return false;\n  }, 'call');\n};\n\n/**\n * Adapts an event with `adapter` before calling `handler`.\n *\n * The `adapter` function receives the same arguments as any handler. The value returned from\n * `adapter` is passed as the first argument to `handler` with the remaining arguments kept the\n * same. This is often useful to generate a custom event payload before forwarding on to a callback.\n *\n * Example:\n * ```\n * import {adaptEvent, forward} from '@enact/core/handle';\n *\n * // calls the onChange callback with an event payload containing a type and value member\n * const incrementAndChange = adaptEvent(\n * \t(ev, props) => ({\n * \t  type: 'onChange',\n * \t  value: props.value + 1\n * \t}),\n * \tforward('onChange')\n * )\n * ```\n *\n * @method   adaptEvent\n * @param    {EventAdapter}     adapter  Function to adapt the event payload\n * @param    {HandlerFunction}  handler  Handler to call with the handler function\n *\n * @returns  {HandlerFunction}           Returns an {@link core/handle.HandlerFunction|event handler} (suitable for passing to handle) that returns the result of `handler`\n * @curried\n * @memberof core/handle\n * @public\n */\nexports.call = call;\nvar adaptEvent = handle.adaptEvent = (0, _curry[\"default\"])(function (adapter, handler) {\n  return named(function (ev) {\n    for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n      args[_key6 - 1] = arguments[_key6];\n    }\n    return handler.call.apply(handler, [this, adapter.call.apply(adapter, [this, ev].concat(args))].concat(args));\n  }, 'adaptEvent');\n});\n\n/**\n * Creates a handler that will forward the event to a function at `name` on `props`.\n *\n * If `adapter` is not specified, a new event payload will be generated with a `type` member with\n * the `name` of the custom event. If `adapter` is specified, the `type` member is added to the\n * value returned by `adapter`.\n *\n * The `adapter` function receives the same arguments as any handler. The value returned from\n * `adapter` is passed as the first argument to `handler` with the remaining arguments kept the\n * same. This is often useful to generate a custom event payload before forwarding on to a callback.\n *\n * Example:\n * ```\n * import {forwardCustom} from '@enact/core/handle';\n *\n * // calls the onChange callback with the event: {type: 'onChange'}\n * const forwardChange = forwardCustom('onChange');\n *\n * // calls the onChange callback with the event: {type: 'onChange', index}\n * const forwardChangeWithIndex = forwardCustom('onChange', (ev, {index}) => ({index}));\n * ```\n *\n * @method   forwardCustom\n * @param    {String}        name      Name of method on the `props`\n * @param    {EventAdapter}  [adapter] Function to adapt the event payload\n *\n * @returns  {HandlerFunction}         Returns an {@link core/handle.EventHandler|event handler}\n *                                     (suitable for passing to handle or used directly within\n *                                     `handlers` in {@link core/kind|kind}) that will forward the\n *                                     custom event.\n * @memberof core/handle\n * @public\n */\nexports.adaptEvent = adaptEvent;\nvar forwardCustom = handle.forwardCustom = function (name, adapter) {\n  return named(adaptEvent(function (ev) {\n    for (var _len7 = arguments.length, args = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n      args[_key7 - 1] = arguments[_key7];\n    }\n    var customEventPayload = adapter ? adapter.call.apply(adapter, [this, ev].concat(args)) : null;\n\n    // Handle either no adapter or a non-object return from the adapter\n    if (!customEventPayload || typeof customEventPayload !== 'object') {\n      customEventPayload = {};\n    }\n    customEventPayload.type = name;\n    if (typeof customEventPayload.preventDefault !== 'function' && typeof (ev === null || ev === void 0 ? void 0 : ev.preventDefault) === 'function') {\n      customEventPayload.preventDefault = ev.preventDefault.bind(ev);\n    }\n    if (typeof customEventPayload.stopPropagation !== 'function' && typeof (ev === null || ev === void 0 ? void 0 : ev.stopPropagation) === 'function') {\n      customEventPayload.stopPropagation = ev.stopPropagation.bind(ev);\n    }\n    return customEventPayload;\n  }, forward(name)), 'forwardCustom');\n};\n\n/**\n * Creates a handler that will forward the event to a function at `name` on `props` with capability\n * to prevent default behavior. If the specified prop is `undefined` or is not a function, it is\n * ignored. The created handler returns `false` when `event.preventDefault()` has been called in a handler.\n *\n * If `adapter` is not specified, a new event payload will be generated with a `type` member with\n * the `name` of the custom event. If `adapter` is specified, the `type` member is added to the\n * value returned by `adapter`.\n *\n * The `adapter` function receives the same arguments as any handler. The value returned from\n * `adapter` is passed as the first argument to `handler` with the remaining arguments kept the\n * same. This is often useful to generate a custom event payload before forwarding on to a callback.\n *\n * Example:\n * ```\n * import {forwardCustomWithPrevent, handle} from '@enact/core/handle';\n *\n * // calls the onChange callback with the event: {type: 'onChange'}\n * const forwardChangePreventDefault = handle(\n *   forwardCustomWithPrevent('onChange'),\n *   (ev) => console.log('default action', ev)\n * );\n *\n * // calls the onChange callback with the event: {type: 'onChange', index}\n * const forwardChangeWithIndexPreventDefault = handle(\n *   forwardCustomWithPrevent('onChange', (ev, {index}) => ({index})),\n *   (ev) => console.log('default action', ev)\n * );\n * ```\n *\n * @method   forwardCustomWithPrevent\n * @param    {String}        name      Name of method on the `props`\n * @param    {EventAdapter}  [adapter] Function to adapt the event payload\n *\n * @returns  {HandlerFunction}         Returns an {@link core/handle.EventHandler|event handler}\n *                                     (suitable for passing to handle or used directly within\n *                                     `handlers` in {@link core/kind|kind}) that will forward the\n *                                     custom event and will return `false` if default action is prevented\n * @memberof core/handle\n * @private\n */\nexports.forwardCustom = forwardCustom;\nvar forwardCustomWithPrevent = handle.forwardCustomWithPrevent = function (name, adapter) {\n  return named(function (ev) {\n    for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n      args[_key8 - 1] = arguments[_key8];\n    }\n    var prevented = false;\n    function adapterWithPrevent() {\n      var customEventPayload = adapter ? adapter.call.apply(adapter, [this, ev].concat(args)) : null;\n      var existingPreventDefault = null;\n\n      // Handle either no adapter or a non-object return from the adapter\n      if (!customEventPayload || typeof customEventPayload !== 'object') {\n        customEventPayload = {};\n      }\n      if (typeof customEventPayload.preventDefault === 'function') {\n        existingPreventDefault = customEventPayload.preventDefault;\n      } else if (typeof (ev === null || ev === void 0 ? void 0 : ev.preventDefault) === 'function') {\n        existingPreventDefault = ev.preventDefault.bind(ev);\n      }\n      customEventPayload.preventDefault = function () {\n        prevented = true;\n        if (typeof existingPreventDefault === 'function') {\n          existingPreventDefault(ev);\n        }\n      };\n      return customEventPayload;\n    }\n    return forwardCustom.call(this, name, adapterWithPrevent.bind(this)).apply(void 0, [ev].concat(args)) && !prevented;\n  }, 'forwardCustomWithPrevent');\n};\n\n/**\n * Accepts a handler and returns the logical complement of the value returned from the handler.\n *\n * Example:\n * ```\n * import {forProp, forward, not, handle} from '@enact/core/handle';\n *\n * // calls the onChange callback when disabled is not true\n * const handleChange = handle(\n *  not(forProp('disabled', true)),\n *  forward('onChange')\n * )\n * ```\n *\n * @method   not\n * @param    {HandlerFunction}  handler  Handler to complement\n *\n * @returns  {HandlerFunction}           Returns an {@link core/handle.HandlerFunction|event handler}\n *                                       (suitable for passing to handle) that returns the complement of the\n *                                       return value of `handler`\n * @curried\n * @memberof core/handle\n * @public\n */\nexports.forwardCustomWithPrevent = forwardCustomWithPrevent;\nvar not = handle.not = function (handler) {\n  return function () {\n    return !handler.apply(void 0, arguments);\n  };\n};\nexports.not = not;\nvar _default = handle;\nexports[\"default\"] = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","stopImmediate","stop","returnsTrue","preventDefault","oneOf","not","log","handle","forwardWithPrevent","forwardCustomWithPrevent","forwardCustom","forward","forProp","forKeyCode","forKey","forEventProp","callOnEvent","call","adaptEvent","_cond","_interopRequireDefault","require","_curry","_keymap","obj","__esModule","makeHandler","handlers","_len","arguments","length","args","Array","_key","i","fn","apply","hasPropsAndContext","prototype","hasOwnProperty","named","name","process","env","NODE_ENV","writeable","enumerable","err","bindAs","namedFunction","bound","bind","decorateHandleFunction","_len2","_key2","h","_outer","prepareHandleArgs","ev","props","context","caller","cleanup","handleWithFinally","result","_len3","_key3","handler","_len4","_key4","methodName","nativeEvent","prop","_preventDefault","prevented","wrappedEvent","assign","is","keyCode","message","_console","_len5","_key5","console","concat","method","adapter","_len6","_key6","_len7","_key7","customEventPayload","type","stopPropagation","_len8","_key8","adapterWithPrevent","existingPreventDefault","_default"],"sources":["/Users/gitchan/Projects/gitchan-yonsei/2024-enact-template/node_modules/@enact/core/handle/handle.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stopImmediate = exports.stop = exports.returnsTrue = exports.preventDefault = exports.oneOf = exports.not = exports.log = exports.handle = exports.forwardWithPrevent = exports.forwardCustomWithPrevent = exports.forwardCustom = exports.forward = exports.forProp = exports.forKeyCode = exports.forKey = exports.forEventProp = exports[\"default\"] = exports.callOnEvent = exports.call = exports.adaptEvent = void 0;\nvar _cond = _interopRequireDefault(require(\"ramda/src/cond\"));\nvar _curry = _interopRequireDefault(require(\"ramda/src/curry\"));\nvar _keymap = require(\"../keymap\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n/**\n * `core/handle` provides a set of utilities to support handling events for `kind()`s and\n * `React.Component`s. The default export, `handle()`, generates an event handler function from a\n * set of input functions. The input functions either process or filter the event. If an input\n * function returns `true`, `handle()` will continue processing the event by calling the next input\n * function in the chain. If it returns `false` (or any falsy value like `null` or `undefined`),\n * the event handling chain stops at that input function.\n *\n * Example:\n * ```\n * import {forKey, forward, handle, preventDefault} from '@enact/core/handle';\n *\n * // logEnter will contain a function that accepts an event, a props object, and a context object\n * const logEnter = handle(\n *   forward('onKeyDown'),  // forwards the event to the function passed in the onKeyDown prop\n *   forKey('enter'),       // if the event.keyCode maps to the enter key, allows event processing to continue\n *   preventDefault,        // calls event.preventDefault() to prevent the `keypress` event\n *   (ev, props) => {       // custom event handler -- in this case, logging some text\n *     // since it doesn't return `true`, no further input functions would be called after this one\n *     console.log('The Enter key was pressed down');\n *   }\n * ).finally(() => {\n * \t console.log('This will log at the end no matter what happens within the handler above')\n * });\n * ```\n *\n * `handle()` can also be bound to a component instance which allows it to access the instance\n * `props` and `context`. This allows you to write consistent event handlers for components created\n * either with `kind()` or ES6 classes without worrying about from where the props are sourced.\n *\n * Handlers can either be bound directly using the native `bind()` method or using the `bindAs()`\n * utility method that is appended to the handler.\n *\n * Example:\n * ```\n * import {forKey, forward, handle, preventDefault} from '@enact/core/handle';\n * import {Component} from 'react';\n *\n * class MyComponent extends Component {\n *   // bind handle() to the instance\n *   constructor () {\n *     super();\n *\n *     // logEnter will be bound to `this` and set as this.handleKeyDown\n *     //\n *     // Equivalent to the following with the advantage of set the function name to be displayed in\n *     // development tool call stacks\n *     //\n *     //   this.handleKeyDown = logEnter.bind(this)\n *     logEnter.bindAs(this, 'handleKeyDown');\n *   }\n *\n *   render () {\n *     return (\n *       <div onKeyDown={this.handleKeyDown} />\n *     );\n *   }\n * }\n * ```\n *\n * @module core/handle\n * @exports adaptEvent\n * @exports call\n * @exports callOnEvent\n * @exports forward\n * @exports forwardWithPrevent\n * @exports forEventProp\n * @exports forKey\n * @exports forKeyCode\n * @exports forProp\n * @exports handle\n * @exports log\n * @exports oneOf\n * @exports preventDefault\n * @exports returnsTrue\n * @exports stop\n * @exports stopImmediate\n */\n\n/**\n * The signature for event handlers\n *\n * @callback EventHandler\n * @memberof core/handle\n * @param {any} event\n */\n\n/**\n * The signature for event handling functions supported by `handle` and related functions\n *\n * @callback HandlerFunction\n * @memberof core/handle\n * @param {any} event\n * @param {Object<string, any>} props\n * @param {Object<string, any>} context\n */\n\n/**\n * The signature for {@link core/handle.adaptEvent} parameter `adapter`\n *\n * @callback EventAdapter\n * @memberof core/handle\n * @param {any} event\n * @param {Object<string, any>} props\n * @param {Object<string, any>} context\n * @returns {any}\n */\n\n// Accepts an array of handlers, sanitizes them, and returns a handler function\n// compose(allPass, map(makeSafeHandler));\nvar makeHandler = function makeHandler(handlers) {\n  // allowing shadowing here to provide a meaningful function name in dev tools\n  // eslint-disable-next-line no-shadow\n  return function handle() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    for (var i = 0; i < handlers.length; i++) {\n      var fn = handlers[i];\n      if (typeof fn !== 'function' || fn.apply(this, args)) {\n        continue;\n      }\n      return false;\n    }\n    return true;\n  };\n};\n\n// Loose check to determine if obj is component-ish if it has both props and context members\nvar hasPropsAndContext = function hasPropsAndContext(obj) {\n  return obj && Object.prototype.hasOwnProperty.call(obj, 'props') && Object.prototype.hasOwnProperty.call(obj, 'context');\n};\nvar named = function named(fn, name) {\n  if (process.env.NODE_ENV !== \"production\") {\n    try {\n      Object.defineProperty(fn, 'name', {\n        value: name,\n        writeable: false,\n        enumerable: false\n      });\n    } catch (err) {\n      // unable to set name of function\n    }\n  }\n  return fn;\n};\nvar bindAs = function bindAs(fn, obj, name) {\n  var namedFunction = name ? named(fn, name) : fn;\n  var bound = namedFunction.bind(obj);\n  if (name) {\n    obj[name] = bound;\n  }\n  return bound;\n};\nvar decorateHandleFunction = function decorateHandleFunction(fn) {\n  fn.named = function (name) {\n    return named(fn, name);\n  };\n  fn.bindAs = function (obj, name) {\n    return bindAs(fn, obj, name);\n  };\n  return fn;\n};\n\n/**\n * Allows generating event handlers by chaining input functions to filter or short-circuit the\n * handling flow. Any input function that returns a falsy value will stop the chain.\n *\n * The returned handler function has a `finally()` member that accepts a function and returns a new\n * handler function. The accepted function is called once the original handler completes regardless\n * of the returned value.\n *\n * @method   handle\n * @param    {...HandlerFunction}  handlers List of handlers to process the event.\n *\n * @returns  {EventHandler}\tA function that accepts an event which is dispatched to each of the\n *                          provided handlers.\n * @memberof core/handle\n * @public\n */\nvar handle = function handle() {\n  for (var _len2 = arguments.length, handlers = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    handlers[_key2] = arguments[_key2];\n  }\n  var h = makeHandler(handlers);\n\n  // In order to support binding either handle (handle.bind(this)) or a handler\n  // (a = handle(), a.bind(this)), we cache `this` here and use it as the fallback for props and\n  // context if fn() doesn't have its own `this`.\n  var _outer = this;\n  var fn = function prepareHandleArgs(ev, props, context) {\n    var caller = null;\n\n    // if handle() was bound to a class, use its props and context. otherwise, we accept\n    // incoming props/context as would be provided by computed/handlers from kind()\n    if (hasPropsAndContext(this)) {\n      caller = this;\n      props = this.props;\n      context = this.context;\n    } else if (hasPropsAndContext(_outer)) {\n      caller = _outer;\n      props = _outer.props;\n      context = _outer.context;\n    }\n    return h.call(caller, ev, props, context);\n  };\n  fn[\"finally\"] = function (cleanup) {\n    return decorateHandleFunction(function handleWithFinally(ev, props, context) {\n      var result = false;\n      if (hasPropsAndContext(this)) {\n        props = this.props;\n        context = this.context;\n      }\n      try {\n        result = fn.call(this, ev, props, context);\n      } finally {\n        cleanup.call(this, ev, props, context);\n      }\n      return result;\n    });\n  };\n  return decorateHandleFunction(fn);\n};\n\n/**\n * Calls the first handler whose condition passes. Each branch must be passed as an array with the\n * first element being the condition function and the second being the handler function. The same\n * arguments are passed to both the condition function and the handler function. The value returned\n * from the handler is returned.\n *\n * Example:\n * ```\n * const handler = oneOf(\n * \t[forKey('enter'), handleEnter],\n * \t[forKey('left'), handleLeft],\n * \t[forKey('right'), handleRight]\n * );\n * ```\n *\n * @method   oneOf\n * @param    {...[HandlerFunction, HandlerFunction]}  handlers List of conditions and handlers to process the event\n *\n * @returns  {HandlerFunction} A function that accepts an event which is dispatched to each of the\n *                             conditions and, if it passes, onto the provided handler.\n * @memberof core/handle\n * @public\n */\nexports.handle = handle;\nvar oneOf = handle.oneOf = function () {\n  for (var _len3 = arguments.length, handlers = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    handlers[_key3] = arguments[_key3];\n  }\n  return handle.call(this, (0, _cond[\"default\"])(handlers));\n};\n\n/**\n * A function that always returns `true`. Optionally accepts a `handler` function which is called\n * before returning `true`.\n *\n * Example:\n * ```\n * // Used to coerce an existing function into a handler\n * const coercedHandler = handle(\n *   returnsTrue(doesSomething),\n *   willAlwaysBeCalled\n * );\n *\n * // Used to emulate if/else blocks with `oneOf`\n * const ifElseHandler = oneOf(\n * \t[forKey('enter'), handleEnter],\n * \t[returnsTrue, handleOtherwise]\n * );\n * ```\n *\n * @method   returnsTrue\n * @param    {Function}  [handler]  Handler function called before returning `true`.\n *\n * @returns  {HandlerFunction}\t   A function that returns `true`\n * @memberof core/handle\n * @public\n */\nexports.oneOf = oneOf;\nvar returnsTrue = handle.returnsTrue = function (handler) {\n  if (handler && typeof handler === 'function') {\n    return named(function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      handler.apply(this, args);\n      return true;\n    }, 'returnsTrue');\n  }\n  return true;\n};\n\n/**\n * Calls a named function on the event and returns `true`.\n *\n * Example:\n * ```\n * import {callOnEvent, handle} from '@enact/core/handle';\n *\n * const callsCustomMethod = handle(\n *\tcallOnEvent('customMethod'),\n *\t(ev) => console.log('ev.customMethod() was called', ev)\n * );\n * ```\n *\n * @method   callOnEvent\n * @param    {String}     methodName  Name of the method to call on the event\n * @param    {Object}     ev          Event payload\n *\n * @returns  {true}                   Always returns `true`\n * @curried\n * @memberof core/handle\n * @private\n */\nexports.returnsTrue = returnsTrue;\nvar callOnEvent = handle.callOnEvent = (0, _curry[\"default\"])(function (methodName, ev) {\n  if (ev[methodName]) {\n    ev[methodName]();\n  } else if (ev.nativeEvent && ev.nativeEvent[methodName]) {\n    // In some cases (notably stopImmediatePropagation), React doesn't include a desired method\n    // on its proxy so we check the native event as well.\n    ev.nativeEvent[methodName]();\n  }\n  return true;\n});\n\n/**\n * Allows handling to continue if the value of `prop` on the event strictly equals `value`\n *\n * Example:\n * ```\n * import {forEventProp, handle} from '@enact/core/handle';\n *\n * const logWhenXEqualsZero = handle(\n *   forEventProp('x', 0),\n *   (ev) => console.log('ev.x was equal to zero', ev)\n * );\n * ```\n *\n * @method   forEventProp\n * @param    {String}\t   prop   Name of property on event\n * @param    {*}           value  Value of property\n * @param    {Object}      ev     Event payload\n *\n * @returns  {Boolean}            Returns `true` if `prop` on `event` strictly equals `value`\n * @curried\n * @memberof core/handle\n * @public\n */\nexports.callOnEvent = callOnEvent;\nvar forEventProp = handle.forEventProp = (0, _curry[\"default\"])(function (prop, value, ev) {\n  return ev[prop] === value;\n});\n\n/**\n * Forwards the event to a function at `name` on `props`. If the specified prop is `undefined` or\n * is not a function, it is ignored. The return value of the forwarded function is ignored and\n * `true` is always returned instead.\n *\n * Example:\n * ```\n * import {forward, handle} from '@enact/core/handle';\n *\n * const forwardAndLog = handle(\n *   forward('onClick'),\n *   (ev) => console.log('event forwarded to onClick from props', ev)\n * );\n * ```\n *\n * @method   forward\n * @param    {String}    name   Name of method on the `props`\n * @param    {Object}    ev     Event payload\n * @param    {Object}    props  Props object\n *\n * @returns  {true}             Always returns `true`\n * @curried\n * @memberof core/handle\n * @public\n */\nexports.forEventProp = forEventProp;\nvar forward = handle.forward = (0, _curry[\"default\"])(named(function (name, ev, props) {\n  var fn = props && props[name];\n  if (typeof fn === 'function') {\n    fn(ev);\n  }\n  return true;\n}, 'forward'));\n\n/**\n * Calls `event.preventDefault()` and returns `true`.\n *\n * Example:\n * ```\n * import {handle, preventDefault} from '@enact/core/handle';\n *\n * const preventAndLog = handle(\n *   preventDefault,\n *   (ev) => console.log('preventDefault called', ev)\n * );\n * ```\n *\n * @method   preventDefault\n * @param    {Object}        ev  Event payload\n *\n * @returns  {true}              Always returns `true`\n * @memberof core/handle\n * @public\n */\nexports.forward = forward;\nvar _preventDefault = handle.preventDefault = callOnEvent('preventDefault');\n\n/**\n * Forwards the event to a function at `name` on `props` with capability to prevent default\n * behavior. If the specified prop is `undefined` or is not a function, it is ignored. Returns\n * `false` when `event.preventDefault()` has been called in a handler.\n *\n * Example:\n * ```\n * import {forwardWithPrevent, handle} from '@enact/core/handle';\n *\n * const forwardPreventDefault = handle(\n *   forwardWithPrevent('onClick'),\n *   (ev) => console.log('default action', ev)\n * );\n * ```\n *\n * @method   forwardWithPrevent\n * @param    {String}    name   Name of method on the `props`\n * @param    {Object}    ev     Event payload\n * @param    {Object}    props  Props object\n *\n * @returns  {Boolean}          Returns `false` if default action is prevented\n * @curried\n * @memberof core/handle\n * @private\n */\nexports.preventDefault = _preventDefault;\nvar forwardWithPrevent = handle.forwardWithPrevent = (0, _curry[\"default\"])(named(function (name, ev, props) {\n  var prevented = false;\n  var wrappedEvent = Object.assign({}, ev, {\n    preventDefault: function preventDefault() {\n      prevented = true;\n      _preventDefault(ev);\n    }\n  });\n  forward(name, wrappedEvent, props);\n  return !prevented;\n}, 'forwardWithPrevent'));\n\n/**\n * Calls `event.stopPropagation()` and returns `true`\n *\n * Example:\n * ```\n * import {handle, stop} from '@enact/core/handle';\n *\n * const stopAndLog = handle(\n *   stop,\n *   (ev) => console.log('stopPropagation called', ev)\n * );\n * ```\n *\n * @method   stop\n * @param    {Object}   ev  Event payload\n *\n * @returns  {true}         Always returns `true`\n * @curried\n * @memberof core/handle\n * @public\n */\nexports.forwardWithPrevent = forwardWithPrevent;\nvar stop = handle.stop = named(callOnEvent('stopPropagation'), 'stop');\n\n/**\n * Calls `event.stopImmediatePropagation()` and returns `true`\n *\n * Example:\n * ```\n * import {handle, stopImmediate} from '@enact/core/handle';\n *\n * const stopImmediateAndLog = handle(\n *   stopImmediate,\n *   (ev) => console.log('stopImmediatePropagation called', ev)\n * );\n * ```\n *\n * @method   stopImmediate\n * @param    {Object}       ev  Event payload\n *\n * @returns  {true}             Always returns `true`\n * @curried\n * @memberof core/handle\n * @public\n */\nexports.stop = stop;\nvar stopImmediate = handle.stopImmediate = callOnEvent('stopImmediatePropagation');\n\n/**\n * Allows event handling to continue if `event.keyCode === value`.\n *\n * Example:\n * ```\n * import {forKeyCode, handle} from '@enact/core/handle';\n *\n * const logForEscapeKey = handle(\n *   forKeyCode(27),\n *   (ev) => console.log('Escape key pressed down', ev)\n * );\n * ```\n *\n * @method   forKeyCode\n * @param    {Number}    value  `keyCode` to test\n * @param    {Object}    ev     Event payload\n *\n * @returns  {Boolean}          Returns `true` if `event.keyCode` strictly equals `value`\n * @curried\n * @memberof core/handle\n * @public\n */\nexports.stopImmediate = stopImmediate;\nvar forKeyCode = handle.forKeyCode = forEventProp('keyCode');\n\n/**\n * Allows handling to continue if the event's keyCode is mapped to `name` within\n * {@link core/keymap}.\n *\n * Example:\n * ```\n * import {forKey, handle} from '@enact/core/handle';\n *\n * const logForEnterKey = handle(\n *   forKey('enter'),\n *   (ev) => console.log('Enter key pressed down', ev)\n * );\n * ```\n *\n * @see      {@link core/keymap}\n * @method   forKey\n * @param    {String}    name   Name from {@link core/keymap}\n * @param    {Object}    ev     Event payload\n *\n * @returns  {Boolean}          Returns `true` if `event.keyCode` is mapped to `name`\n * @curried\n * @memberof core/handle\n * @public\n */\nexports.forKeyCode = forKeyCode;\nvar forKey = handle.forKey = (0, _curry[\"default\"])(function (name, ev) {\n  return (0, _keymap.is)(name, ev.keyCode);\n});\n\n/**\n * Allows handling to continue if the value of `prop` on the props strictly equals `value`.\n *\n * Example:\n * ```\n * import {forProp, handle} from '@enact/core/handle';\n *\n * const logWhenChecked = handle(\n *   forProp('checked', true),\n *   (ev) => console.log('checked prop is true', ev)\n * );\n * ```\n *\n * @method   forProp\n * @param    {String}    prop   Name of property on props object\n * @param    {*}         value  Value of property\n * @param    {Object}    ev     Event payload\n * @param    {Object}    props  Props object\n *\n * @returns  {Boolean}          Returns `true` if the value of `props[prop]` strictly equals `value`\n * @curried\n * @memberof core/handle\n * @public\n */\nexports.forKey = forKey;\nvar forProp = handle.forProp = (0, _curry[\"default\"])(function (prop, value, ev, props) {\n  return props[prop] === value;\n});\n\n/**\n * Logs the event, props, and context optionally preceded by a custom message. Will only log in\n * development mode.\n *\n * Example:\n * ```\n * import {forProp, handle, log} from '@enact/core/handle';\n *\n * const logWhenChecked = handle(\n *   forProp('checked', true),\n *   log('checked props is true')\n * );\n * ```\n *\n * @method   log\n * @param    {String}     message  Custom message\n * @param    {Object}     ev       Event payload\n * @param    {...*}       [args]   Any args passed are logged\n *\n * @returns  {true}                Always returns `true`\n * @curried\n * @memberof core/handle\n * @public\n */\nexports.forProp = forProp;\nvar log = handle.log = (0, _curry[\"default\"])(function (message, ev) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var _console;\n    for (var _len5 = arguments.length, args = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n      args[_key5 - 2] = arguments[_key5];\n    }\n    // eslint-disable-next-line no-console\n    (_console = console).log.apply(_console, [message, ev].concat(args));\n  }\n  return true;\n});\n\n/**\n * Invokes a method by name on the component to which {@link core/handle.handle} is bound.\n *\n * If the methods exists on the object, it is called with the event, props, and context and its\n * return value is returned.\n *\n * If the method does not exist or handle isn't bound to an instance, it returns `false`.\n *\n * Example:\n * ```\n * import {call, handle, forProp} from '@enact/core/handle';\n *\n * const incrementIfEnabled = handle(\n *   forProp('disabled', false),\n *   call('increment')\n * );\n *\n * class Counter extends React.Component {\n *   constructor () {\n *     super();\n *\n *     this.handleIncrement = incrementIfEnabled.bind(this);\n *   }\n *\n *   render () {\n *     // ...\n *   }\n * }\n * ```\n *\n * @method   call\n * @param    {String}     method  Name of method\n *\n * @returns  {HandlerFunction}    Returns the value returned by `method`, or `false` if the method\n *                                does not exist\n * @memberof core/handle\n * @public\n */\nexports.log = log;\nvar call = function call(method) {\n  return named(function () {\n    if (this && this[method]) {\n      return this[method].apply(this, arguments);\n    }\n    return false;\n  }, 'call');\n};\n\n/**\n * Adapts an event with `adapter` before calling `handler`.\n *\n * The `adapter` function receives the same arguments as any handler. The value returned from\n * `adapter` is passed as the first argument to `handler` with the remaining arguments kept the\n * same. This is often useful to generate a custom event payload before forwarding on to a callback.\n *\n * Example:\n * ```\n * import {adaptEvent, forward} from '@enact/core/handle';\n *\n * // calls the onChange callback with an event payload containing a type and value member\n * const incrementAndChange = adaptEvent(\n * \t(ev, props) => ({\n * \t  type: 'onChange',\n * \t  value: props.value + 1\n * \t}),\n * \tforward('onChange')\n * )\n * ```\n *\n * @method   adaptEvent\n * @param    {EventAdapter}     adapter  Function to adapt the event payload\n * @param    {HandlerFunction}  handler  Handler to call with the handler function\n *\n * @returns  {HandlerFunction}           Returns an {@link core/handle.HandlerFunction|event handler} (suitable for passing to handle) that returns the result of `handler`\n * @curried\n * @memberof core/handle\n * @public\n */\nexports.call = call;\nvar adaptEvent = handle.adaptEvent = (0, _curry[\"default\"])(function (adapter, handler) {\n  return named(function (ev) {\n    for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n      args[_key6 - 1] = arguments[_key6];\n    }\n    return handler.call.apply(handler, [this, adapter.call.apply(adapter, [this, ev].concat(args))].concat(args));\n  }, 'adaptEvent');\n});\n\n/**\n * Creates a handler that will forward the event to a function at `name` on `props`.\n *\n * If `adapter` is not specified, a new event payload will be generated with a `type` member with\n * the `name` of the custom event. If `adapter` is specified, the `type` member is added to the\n * value returned by `adapter`.\n *\n * The `adapter` function receives the same arguments as any handler. The value returned from\n * `adapter` is passed as the first argument to `handler` with the remaining arguments kept the\n * same. This is often useful to generate a custom event payload before forwarding on to a callback.\n *\n * Example:\n * ```\n * import {forwardCustom} from '@enact/core/handle';\n *\n * // calls the onChange callback with the event: {type: 'onChange'}\n * const forwardChange = forwardCustom('onChange');\n *\n * // calls the onChange callback with the event: {type: 'onChange', index}\n * const forwardChangeWithIndex = forwardCustom('onChange', (ev, {index}) => ({index}));\n * ```\n *\n * @method   forwardCustom\n * @param    {String}        name      Name of method on the `props`\n * @param    {EventAdapter}  [adapter] Function to adapt the event payload\n *\n * @returns  {HandlerFunction}         Returns an {@link core/handle.EventHandler|event handler}\n *                                     (suitable for passing to handle or used directly within\n *                                     `handlers` in {@link core/kind|kind}) that will forward the\n *                                     custom event.\n * @memberof core/handle\n * @public\n */\nexports.adaptEvent = adaptEvent;\nvar forwardCustom = handle.forwardCustom = function (name, adapter) {\n  return named(adaptEvent(function (ev) {\n    for (var _len7 = arguments.length, args = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n      args[_key7 - 1] = arguments[_key7];\n    }\n    var customEventPayload = adapter ? adapter.call.apply(adapter, [this, ev].concat(args)) : null;\n\n    // Handle either no adapter or a non-object return from the adapter\n    if (!customEventPayload || typeof customEventPayload !== 'object') {\n      customEventPayload = {};\n    }\n    customEventPayload.type = name;\n    if (typeof customEventPayload.preventDefault !== 'function' && typeof (ev === null || ev === void 0 ? void 0 : ev.preventDefault) === 'function') {\n      customEventPayload.preventDefault = ev.preventDefault.bind(ev);\n    }\n    if (typeof customEventPayload.stopPropagation !== 'function' && typeof (ev === null || ev === void 0 ? void 0 : ev.stopPropagation) === 'function') {\n      customEventPayload.stopPropagation = ev.stopPropagation.bind(ev);\n    }\n    return customEventPayload;\n  }, forward(name)), 'forwardCustom');\n};\n\n/**\n * Creates a handler that will forward the event to a function at `name` on `props` with capability\n * to prevent default behavior. If the specified prop is `undefined` or is not a function, it is\n * ignored. The created handler returns `false` when `event.preventDefault()` has been called in a handler.\n *\n * If `adapter` is not specified, a new event payload will be generated with a `type` member with\n * the `name` of the custom event. If `adapter` is specified, the `type` member is added to the\n * value returned by `adapter`.\n *\n * The `adapter` function receives the same arguments as any handler. The value returned from\n * `adapter` is passed as the first argument to `handler` with the remaining arguments kept the\n * same. This is often useful to generate a custom event payload before forwarding on to a callback.\n *\n * Example:\n * ```\n * import {forwardCustomWithPrevent, handle} from '@enact/core/handle';\n *\n * // calls the onChange callback with the event: {type: 'onChange'}\n * const forwardChangePreventDefault = handle(\n *   forwardCustomWithPrevent('onChange'),\n *   (ev) => console.log('default action', ev)\n * );\n *\n * // calls the onChange callback with the event: {type: 'onChange', index}\n * const forwardChangeWithIndexPreventDefault = handle(\n *   forwardCustomWithPrevent('onChange', (ev, {index}) => ({index})),\n *   (ev) => console.log('default action', ev)\n * );\n * ```\n *\n * @method   forwardCustomWithPrevent\n * @param    {String}        name      Name of method on the `props`\n * @param    {EventAdapter}  [adapter] Function to adapt the event payload\n *\n * @returns  {HandlerFunction}         Returns an {@link core/handle.EventHandler|event handler}\n *                                     (suitable for passing to handle or used directly within\n *                                     `handlers` in {@link core/kind|kind}) that will forward the\n *                                     custom event and will return `false` if default action is prevented\n * @memberof core/handle\n * @private\n */\nexports.forwardCustom = forwardCustom;\nvar forwardCustomWithPrevent = handle.forwardCustomWithPrevent = function (name, adapter) {\n  return named(function (ev) {\n    for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n      args[_key8 - 1] = arguments[_key8];\n    }\n    var prevented = false;\n    function adapterWithPrevent() {\n      var customEventPayload = adapter ? adapter.call.apply(adapter, [this, ev].concat(args)) : null;\n      var existingPreventDefault = null;\n\n      // Handle either no adapter or a non-object return from the adapter\n      if (!customEventPayload || typeof customEventPayload !== 'object') {\n        customEventPayload = {};\n      }\n      if (typeof customEventPayload.preventDefault === 'function') {\n        existingPreventDefault = customEventPayload.preventDefault;\n      } else if (typeof (ev === null || ev === void 0 ? void 0 : ev.preventDefault) === 'function') {\n        existingPreventDefault = ev.preventDefault.bind(ev);\n      }\n      customEventPayload.preventDefault = function () {\n        prevented = true;\n        if (typeof existingPreventDefault === 'function') {\n          existingPreventDefault(ev);\n        }\n      };\n      return customEventPayload;\n    }\n    return forwardCustom.call(this, name, adapterWithPrevent.bind(this)).apply(void 0, [ev].concat(args)) && !prevented;\n  }, 'forwardCustomWithPrevent');\n};\n\n/**\n * Accepts a handler and returns the logical complement of the value returned from the handler.\n *\n * Example:\n * ```\n * import {forProp, forward, not, handle} from '@enact/core/handle';\n *\n * // calls the onChange callback when disabled is not true\n * const handleChange = handle(\n *  not(forProp('disabled', true)),\n *  forward('onChange')\n * )\n * ```\n *\n * @method   not\n * @param    {HandlerFunction}  handler  Handler to complement\n *\n * @returns  {HandlerFunction}           Returns an {@link core/handle.HandlerFunction|event handler}\n *                                       (suitable for passing to handle) that returns the complement of the\n *                                       return value of `handler`\n * @curried\n * @memberof core/handle\n * @public\n */\nexports.forwardCustomWithPrevent = forwardCustomWithPrevent;\nvar not = handle.not = function (handler) {\n  return function () {\n    return !handler.apply(void 0, arguments);\n  };\n};\nexports.not = not;\nvar _default = handle;\nexports[\"default\"] = _default;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}