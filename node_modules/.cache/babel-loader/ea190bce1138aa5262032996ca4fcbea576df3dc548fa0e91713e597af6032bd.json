{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPosition = exports.getLabelOffset = exports.calcOverflow = exports.adjustDirection = exports.adjustAnchor = void 0;\nvar _resolution = _interopRequireDefault(require(\"@enact/ui/resolution\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n// TooltipDecorator util.js\n//\n\n/**\n * Calculates the unusable space of a centered Tooltip, which the Tooltip arrow cannot be positioned,\n * as a percentage of the Tooltip's total width.\n *\n * @param  {Number} tooltipWidth        The measured width of the Tooltip\n * @return {Number}                     The percent of the width of the tooltip that the Tooltip's\n *                                      decorations allocate for themselves (on one side).\n * @private\n */\nvar getLabelUnavailableSpace = function getLabelUnavailableSpace(tooltipWidth) {\n  // Arrow is 30px wide total, we need to know how wide half of it is, since it's centered on the anchor point.\n  var arrowWidth = 30 / 2;\n\n  // Tooltip is 108px tall, divide by half to get the curve radius, add the tooltip width\n  // to determine the distance that the anchor cannot progress past.\n  var tooltipUnavailableEdge = _resolution[\"default\"].scale(108 / 2 + arrowWidth);\n\n  // cap the offset at 50% - that percentage\n  var tooltipUnavaliablePercentage = 0.5 - tooltipUnavailableEdge / tooltipWidth;\n  return tooltipUnavaliablePercentage;\n};\n\n/**\n * Adjust anchor position for `Tooltip` based on overflow and rtl.\n * Takes the output of `adjustDirection`, and `calcOverflow`.\n *\n * @method\n * @memberof sandstone/TooltipDecorator\n * @param   {String}  arrowAnchor       Initial anchor position\n * @param   {String}  tooltipDirection  Direction of tooltip; value from `adjustDirection`\n * @param   {Object}  overflow          Tooltip's calculated overflow from `calcOverflow`\n * @param   {Boolean} rtl               RTL mode\n * @returns {String}                    Adjusted anchor position\n * @private\n */\nvar adjustAnchor = function adjustAnchor(arrowAnchor, tooltipDirection, overflow, rtl) {\n  if (tooltipDirection === 'above' || tooltipDirection === 'below') {\n    if (rtl && arrowAnchor !== 'center') {\n      arrowAnchor = arrowAnchor === 'left' ? 'right' : 'left';\n    }\n\n    // Flip sideways if it overflows to the sides\n    if (arrowAnchor === 'center') {\n      // If tooltip is anchored in the center, don't flip. We'll offset it appropriately later.\n    } else if (overflow.isOverRight) {\n      arrowAnchor = 'left';\n    } else if (overflow.isOverLeft) {\n      arrowAnchor = 'right';\n    }\n\n    // If tooltip is just too wide for the whole screen, switch it to a center tooltip\n    if (overflow.isOverWide && tooltipDirection !== 'left' && tooltipDirection !== 'right') {\n      arrowAnchor = 'center';\n    }\n  }\n  return arrowAnchor;\n};\n\n/**\n * Adjust direction for `Tooltip` based on overflow and rtl.\n * Takes the output from `calcOverflow`.\n *\n * @method\n * @memberof sandstone/TooltipDecorator\n * @param   {String}  tooltipDirection  Direction of tooltip\n * @param   {Object}  overflow          Tooltip's calculated overflow from `calcOverflow`\n * @param   {Boolean} rtl               RTL mode\n * @returns {String}                    Adjusted tooltip direction\n * @private\n */\nexports.adjustAnchor = adjustAnchor;\nvar adjustDirection = function adjustDirection(tooltipDirection, overflow, rtl) {\n  if (rtl && (tooltipDirection === 'left' || tooltipDirection === 'right')) {\n    tooltipDirection = tooltipDirection === 'left' ? 'right' : 'left';\n  }\n\n  // Flip tooltip if it overflows towards the tooltip direction\n  if (overflow.isOverTop && tooltipDirection === 'above') {\n    tooltipDirection = 'below';\n  } else if (overflow.isOverBottom && tooltipDirection === 'below') {\n    tooltipDirection = 'above';\n  } else if (overflow.isOverLeft && tooltipDirection === 'left' && !overflow.isOverWide) {\n    tooltipDirection = 'right';\n  } else if (overflow.isOverRight && tooltipDirection === 'right' && !overflow.isOverWide) {\n    tooltipDirection = 'left';\n  }\n  return tooltipDirection;\n};\n\n/**\n * Calculates the overflow of `Tooltip` â€” if `Tooltip` is at the edge of the viewport.\n * Return the amount of overflow in a particular direction if there is overflow (false otherwise).\n *\n * @method\n * @memberof sandstone/TooltipDecorator\n * @param   {Object} tooltipNode        The `getBoundingClientRect` values for tooltip node\n * @param   {Object} clientNode         The `getBoundingClientRect` values for client node\n * @param   {String} tooltipDirection   Direction of tooltip\n * @param   {Number} tooltipHeight      Tooltip height\n * @param   {Number} edgeKeepout        Extra margin around the screen to avoid\n * @returns {Object}                    Tooltip's calculated overflow\n * @private\n */\nexports.adjustDirection = adjustDirection;\nvar calcOverflow = function calcOverflow(tooltipNode, clientNode, tooltipDirection, edgeKeepout) {\n  // get the distance of space on both the right and left side of the client node. `clientNode.width / 2` because we want the tooltip to be positioned horizontally in middle of the client node.\n  var windowWidth = window.innerWidth;\n  var windowHeight = window.innerHeight;\n  var clientHorizontalCenter = clientNode.left + clientNode.width / 2;\n  var tooltipSafeWidth = tooltipNode.width + edgeKeepout;\n  var tooltipCenterdSafeWidth = tooltipNode.width / 2 + edgeKeepout;\n  var rightDelta = tooltipSafeWidth > clientHorizontalCenter;\n  var leftDelta = tooltipSafeWidth > windowWidth - clientHorizontalCenter;\n  var isTooltipWide = tooltipSafeWidth > windowWidth || leftDelta && rightDelta;\n  if (tooltipDirection === 'above' || tooltipDirection === 'below') {\n    var isOverTop = clientNode.top - tooltipNode.height - edgeKeepout;\n    var isOverBottom = clientNode.bottom + tooltipNode.height + edgeKeepout;\n    var isOverLeft = clientHorizontalCenter - tooltipSafeWidth;\n    var isOverRight = clientHorizontalCenter + tooltipSafeWidth;\n    var isOverCenterLeft = clientHorizontalCenter - tooltipCenterdSafeWidth;\n    var isOverCenterRight = clientHorizontalCenter + tooltipCenterdSafeWidth;\n    return {\n      isOverTop: isOverTop < 0 ? isOverTop : false,\n      isOverBottom: isOverBottom > windowHeight ? isOverBottom - windowHeight : false,\n      isOverLeft: isOverLeft < 0 ? isOverLeft : false,\n      isOverRight: isOverRight > windowWidth ? isOverRight - windowWidth : false,\n      isOverCenterLeft: isOverCenterLeft < 0 ? isOverCenterLeft : false,\n      isOverCenterRight: isOverCenterRight > windowWidth ? isOverCenterRight - windowWidth : false,\n      isOverWide: isTooltipWide\n    };\n  } else if (tooltipDirection === 'left' || tooltipDirection === 'right') {\n    var _isOverTop = clientNode.top - tooltipNode.height + clientNode.height - edgeKeepout;\n    var _isOverBottom = clientNode.bottom + tooltipNode.height - clientNode.height / 2 + edgeKeepout;\n    var _isOverLeft = clientNode.left - tooltipNode.width - edgeKeepout;\n    var _isOverRight = clientNode.right + tooltipNode.width + edgeKeepout;\n    return {\n      isOverTop: _isOverTop < 0 ? _isOverTop : false,\n      isOverBottom: _isOverBottom > windowHeight ? _isOverBottom - windowHeight : false,\n      isOverLeft: _isOverLeft < 0 ? _isOverLeft : false,\n      isOverRight: _isOverRight > windowWidth ? _isOverRight - windowWidth : false,\n      isOverWide: isTooltipWide\n    };\n  }\n};\n\n/**\n * Calculates the top and left position for `Tooltip`.\n * Takes the output of `adjustAnchor`, `adjustDirection`, and `calcOverflow`.\n *\n * @method\n * @memberof sandstone/TooltipDecorator\n * @param   {Object} tooltipNode        The `getBoundingClientRect` values for tooltip node\n * @param   {Object} clientNode         The `getBoundingClientRect` values for client node\n * @param   {String} arrowAnchor        Anchor position from `adjustAnchor`\n * @param   {String} tooltipDirection   Direction of tooltip\n * @param   {Number} tooltipHeight      Tooltip height\n * @param   {Object} overflow           Tooltip's calculated overflow from `calcOverflow`\n * @param   {Boolean} rtl               RTL mode\n * @returns {Object}                    Tooltip top and left position\n * @private\n */\nexports.calcOverflow = calcOverflow;\nvar getPosition = function getPosition(clientNode, tooltipDirection) {\n  var position = {};\n  switch (tooltipDirection) {\n    case 'above':\n      position.top = clientNode.top;\n      break;\n    case 'below':\n      position.top = clientNode.bottom;\n      break;\n    case 'right':\n      position.left = clientNode.right;\n      break;\n    case 'left':\n      position.left = clientNode.left;\n      break;\n    default:\n      position = {};\n  }\n  if (tooltipDirection === 'above' || tooltipDirection === 'below') {\n    position.left = clientNode.left + clientNode.width / 2;\n  } else if (tooltipDirection === 'left' || tooltipDirection === 'right') {\n    position.top = clientNode.top + clientNode.height / 2;\n  }\n  return position;\n};\n\n/**\n * Adjusts the `Tooltip` arrow anchor when the tooltip is too wide.\n * Takes the output of `calcOverflow`.\n *\n * @method\n * @memberof sandstone/TooltipDecorator\n * @param   {Object}  tooltipNode       The `getBoundingClientRect` values for tooltip node\n * @param   {String}  tooltipDirection  Direction of tooltip\n * @param   {Object}  tooltipPosition   Calculated tooltip position from `getPosition`\n * @param   {Object}  overflow          Tooltip's calculated overflow from `calcOverflow`\n * @private\n */\nexports.getPosition = getPosition;\nvar getLabelOffset = function getLabelOffset(tooltipNode, tooltipDirection, tooltipPosition, overflow) {\n  // This method is irrelevent to left and right anchored tooltips, skip entirely.\n  if (tooltipDirection !== 'left' && tooltipDirection !== 'right') {\n    var tooltipWidth = tooltipNode.width;\n    if (overflow.isOverWide || overflow.isOverCenterLeft || overflow.isOverCenterRight) {\n      var pixelOffset = 0;\n      if (overflow.isOverCenterLeft) {\n        // Start shifting the label to the right (negative offset)\n        pixelOffset = overflow.isOverCenterLeft;\n      } else if (overflow.isOverCenterRight) {\n        // Start shifting the label to the left (positive offset)\n        pixelOffset = overflow.isOverCenterRight;\n      }\n      var percentageOffset = pixelOffset / tooltipWidth * -1;\n      var offsetBoundaryPercentage = getLabelUnavailableSpace(tooltipWidth);\n      var cappedPercentageOffset = Math.max(offsetBoundaryPercentage * -1, Math.min(offsetBoundaryPercentage, percentageOffset));\n      return cappedPercentageOffset;\n    }\n  }\n  return null;\n};\nexports.getLabelOffset = getLabelOffset;","map":{"version":3,"names":["Object","defineProperty","exports","value","getPosition","getLabelOffset","calcOverflow","adjustDirection","adjustAnchor","_resolution","_interopRequireDefault","require","obj","__esModule","getLabelUnavailableSpace","tooltipWidth","arrowWidth","tooltipUnavailableEdge","scale","tooltipUnavaliablePercentage","arrowAnchor","tooltipDirection","overflow","rtl","isOverRight","isOverLeft","isOverWide","isOverTop","isOverBottom","tooltipNode","clientNode","edgeKeepout","windowWidth","window","innerWidth","windowHeight","innerHeight","clientHorizontalCenter","left","width","tooltipSafeWidth","tooltipCenterdSafeWidth","rightDelta","leftDelta","isTooltipWide","top","height","bottom","isOverCenterLeft","isOverCenterRight","_isOverTop","_isOverBottom","_isOverLeft","_isOverRight","right","position","tooltipPosition","pixelOffset","percentageOffset","offsetBoundaryPercentage","cappedPercentageOffset","Math","max","min"],"sources":["/Users/gitchan/Projects/gitchan-yonsei/2024-enact-template/node_modules/@enact/sandstone/TooltipDecorator/util.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPosition = exports.getLabelOffset = exports.calcOverflow = exports.adjustDirection = exports.adjustAnchor = void 0;\nvar _resolution = _interopRequireDefault(require(\"@enact/ui/resolution\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n// TooltipDecorator util.js\n//\n\n/**\n * Calculates the unusable space of a centered Tooltip, which the Tooltip arrow cannot be positioned,\n * as a percentage of the Tooltip's total width.\n *\n * @param  {Number} tooltipWidth        The measured width of the Tooltip\n * @return {Number}                     The percent of the width of the tooltip that the Tooltip's\n *                                      decorations allocate for themselves (on one side).\n * @private\n */\nvar getLabelUnavailableSpace = function getLabelUnavailableSpace(tooltipWidth) {\n  // Arrow is 30px wide total, we need to know how wide half of it is, since it's centered on the anchor point.\n  var arrowWidth = 30 / 2;\n\n  // Tooltip is 108px tall, divide by half to get the curve radius, add the tooltip width\n  // to determine the distance that the anchor cannot progress past.\n  var tooltipUnavailableEdge = _resolution[\"default\"].scale(108 / 2 + arrowWidth);\n\n  // cap the offset at 50% - that percentage\n  var tooltipUnavaliablePercentage = 0.5 - tooltipUnavailableEdge / tooltipWidth;\n  return tooltipUnavaliablePercentage;\n};\n\n/**\n * Adjust anchor position for `Tooltip` based on overflow and rtl.\n * Takes the output of `adjustDirection`, and `calcOverflow`.\n *\n * @method\n * @memberof sandstone/TooltipDecorator\n * @param   {String}  arrowAnchor       Initial anchor position\n * @param   {String}  tooltipDirection  Direction of tooltip; value from `adjustDirection`\n * @param   {Object}  overflow          Tooltip's calculated overflow from `calcOverflow`\n * @param   {Boolean} rtl               RTL mode\n * @returns {String}                    Adjusted anchor position\n * @private\n */\nvar adjustAnchor = function adjustAnchor(arrowAnchor, tooltipDirection, overflow, rtl) {\n  if (tooltipDirection === 'above' || tooltipDirection === 'below') {\n    if (rtl && arrowAnchor !== 'center') {\n      arrowAnchor = arrowAnchor === 'left' ? 'right' : 'left';\n    }\n\n    // Flip sideways if it overflows to the sides\n    if (arrowAnchor === 'center') {\n      // If tooltip is anchored in the center, don't flip. We'll offset it appropriately later.\n    } else if (overflow.isOverRight) {\n      arrowAnchor = 'left';\n    } else if (overflow.isOverLeft) {\n      arrowAnchor = 'right';\n    }\n\n    // If tooltip is just too wide for the whole screen, switch it to a center tooltip\n    if (overflow.isOverWide && tooltipDirection !== 'left' && tooltipDirection !== 'right') {\n      arrowAnchor = 'center';\n    }\n  }\n  return arrowAnchor;\n};\n\n/**\n * Adjust direction for `Tooltip` based on overflow and rtl.\n * Takes the output from `calcOverflow`.\n *\n * @method\n * @memberof sandstone/TooltipDecorator\n * @param   {String}  tooltipDirection  Direction of tooltip\n * @param   {Object}  overflow          Tooltip's calculated overflow from `calcOverflow`\n * @param   {Boolean} rtl               RTL mode\n * @returns {String}                    Adjusted tooltip direction\n * @private\n */\nexports.adjustAnchor = adjustAnchor;\nvar adjustDirection = function adjustDirection(tooltipDirection, overflow, rtl) {\n  if (rtl && (tooltipDirection === 'left' || tooltipDirection === 'right')) {\n    tooltipDirection = tooltipDirection === 'left' ? 'right' : 'left';\n  }\n\n  // Flip tooltip if it overflows towards the tooltip direction\n  if (overflow.isOverTop && tooltipDirection === 'above') {\n    tooltipDirection = 'below';\n  } else if (overflow.isOverBottom && tooltipDirection === 'below') {\n    tooltipDirection = 'above';\n  } else if (overflow.isOverLeft && tooltipDirection === 'left' && !overflow.isOverWide) {\n    tooltipDirection = 'right';\n  } else if (overflow.isOverRight && tooltipDirection === 'right' && !overflow.isOverWide) {\n    tooltipDirection = 'left';\n  }\n  return tooltipDirection;\n};\n\n/**\n * Calculates the overflow of `Tooltip` â€” if `Tooltip` is at the edge of the viewport.\n * Return the amount of overflow in a particular direction if there is overflow (false otherwise).\n *\n * @method\n * @memberof sandstone/TooltipDecorator\n * @param   {Object} tooltipNode        The `getBoundingClientRect` values for tooltip node\n * @param   {Object} clientNode         The `getBoundingClientRect` values for client node\n * @param   {String} tooltipDirection   Direction of tooltip\n * @param   {Number} tooltipHeight      Tooltip height\n * @param   {Number} edgeKeepout        Extra margin around the screen to avoid\n * @returns {Object}                    Tooltip's calculated overflow\n * @private\n */\nexports.adjustDirection = adjustDirection;\nvar calcOverflow = function calcOverflow(tooltipNode, clientNode, tooltipDirection, edgeKeepout) {\n  // get the distance of space on both the right and left side of the client node. `clientNode.width / 2` because we want the tooltip to be positioned horizontally in middle of the client node.\n  var windowWidth = window.innerWidth;\n  var windowHeight = window.innerHeight;\n  var clientHorizontalCenter = clientNode.left + clientNode.width / 2;\n  var tooltipSafeWidth = tooltipNode.width + edgeKeepout;\n  var tooltipCenterdSafeWidth = tooltipNode.width / 2 + edgeKeepout;\n  var rightDelta = tooltipSafeWidth > clientHorizontalCenter;\n  var leftDelta = tooltipSafeWidth > windowWidth - clientHorizontalCenter;\n  var isTooltipWide = tooltipSafeWidth > windowWidth || leftDelta && rightDelta;\n  if (tooltipDirection === 'above' || tooltipDirection === 'below') {\n    var isOverTop = clientNode.top - tooltipNode.height - edgeKeepout;\n    var isOverBottom = clientNode.bottom + tooltipNode.height + edgeKeepout;\n    var isOverLeft = clientHorizontalCenter - tooltipSafeWidth;\n    var isOverRight = clientHorizontalCenter + tooltipSafeWidth;\n    var isOverCenterLeft = clientHorizontalCenter - tooltipCenterdSafeWidth;\n    var isOverCenterRight = clientHorizontalCenter + tooltipCenterdSafeWidth;\n    return {\n      isOverTop: isOverTop < 0 ? isOverTop : false,\n      isOverBottom: isOverBottom > windowHeight ? isOverBottom - windowHeight : false,\n      isOverLeft: isOverLeft < 0 ? isOverLeft : false,\n      isOverRight: isOverRight > windowWidth ? isOverRight - windowWidth : false,\n      isOverCenterLeft: isOverCenterLeft < 0 ? isOverCenterLeft : false,\n      isOverCenterRight: isOverCenterRight > windowWidth ? isOverCenterRight - windowWidth : false,\n      isOverWide: isTooltipWide\n    };\n  } else if (tooltipDirection === 'left' || tooltipDirection === 'right') {\n    var _isOverTop = clientNode.top - tooltipNode.height + clientNode.height - edgeKeepout;\n    var _isOverBottom = clientNode.bottom + tooltipNode.height - clientNode.height / 2 + edgeKeepout;\n    var _isOverLeft = clientNode.left - tooltipNode.width - edgeKeepout;\n    var _isOverRight = clientNode.right + tooltipNode.width + edgeKeepout;\n    return {\n      isOverTop: _isOverTop < 0 ? _isOverTop : false,\n      isOverBottom: _isOverBottom > windowHeight ? _isOverBottom - windowHeight : false,\n      isOverLeft: _isOverLeft < 0 ? _isOverLeft : false,\n      isOverRight: _isOverRight > windowWidth ? _isOverRight - windowWidth : false,\n      isOverWide: isTooltipWide\n    };\n  }\n};\n\n/**\n * Calculates the top and left position for `Tooltip`.\n * Takes the output of `adjustAnchor`, `adjustDirection`, and `calcOverflow`.\n *\n * @method\n * @memberof sandstone/TooltipDecorator\n * @param   {Object} tooltipNode        The `getBoundingClientRect` values for tooltip node\n * @param   {Object} clientNode         The `getBoundingClientRect` values for client node\n * @param   {String} arrowAnchor        Anchor position from `adjustAnchor`\n * @param   {String} tooltipDirection   Direction of tooltip\n * @param   {Number} tooltipHeight      Tooltip height\n * @param   {Object} overflow           Tooltip's calculated overflow from `calcOverflow`\n * @param   {Boolean} rtl               RTL mode\n * @returns {Object}                    Tooltip top and left position\n * @private\n */\nexports.calcOverflow = calcOverflow;\nvar getPosition = function getPosition(clientNode, tooltipDirection) {\n  var position = {};\n  switch (tooltipDirection) {\n    case 'above':\n      position.top = clientNode.top;\n      break;\n    case 'below':\n      position.top = clientNode.bottom;\n      break;\n    case 'right':\n      position.left = clientNode.right;\n      break;\n    case 'left':\n      position.left = clientNode.left;\n      break;\n    default:\n      position = {};\n  }\n  if (tooltipDirection === 'above' || tooltipDirection === 'below') {\n    position.left = clientNode.left + clientNode.width / 2;\n  } else if (tooltipDirection === 'left' || tooltipDirection === 'right') {\n    position.top = clientNode.top + clientNode.height / 2;\n  }\n  return position;\n};\n\n/**\n * Adjusts the `Tooltip` arrow anchor when the tooltip is too wide.\n * Takes the output of `calcOverflow`.\n *\n * @method\n * @memberof sandstone/TooltipDecorator\n * @param   {Object}  tooltipNode       The `getBoundingClientRect` values for tooltip node\n * @param   {String}  tooltipDirection  Direction of tooltip\n * @param   {Object}  tooltipPosition   Calculated tooltip position from `getPosition`\n * @param   {Object}  overflow          Tooltip's calculated overflow from `calcOverflow`\n * @private\n */\nexports.getPosition = getPosition;\nvar getLabelOffset = function getLabelOffset(tooltipNode, tooltipDirection, tooltipPosition, overflow) {\n  // This method is irrelevent to left and right anchored tooltips, skip entirely.\n  if (tooltipDirection !== 'left' && tooltipDirection !== 'right') {\n    var tooltipWidth = tooltipNode.width;\n    if (overflow.isOverWide || overflow.isOverCenterLeft || overflow.isOverCenterRight) {\n      var pixelOffset = 0;\n      if (overflow.isOverCenterLeft) {\n        // Start shifting the label to the right (negative offset)\n        pixelOffset = overflow.isOverCenterLeft;\n      } else if (overflow.isOverCenterRight) {\n        // Start shifting the label to the left (positive offset)\n        pixelOffset = overflow.isOverCenterRight;\n      }\n      var percentageOffset = pixelOffset / tooltipWidth * -1;\n      var offsetBoundaryPercentage = getLabelUnavailableSpace(tooltipWidth);\n      var cappedPercentageOffset = Math.max(offsetBoundaryPercentage * -1, Math.min(offsetBoundaryPercentage, percentageOffset));\n      return cappedPercentageOffset;\n    }\n  }\n  return null;\n};\nexports.getLabelOffset = getLabelOffset;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}