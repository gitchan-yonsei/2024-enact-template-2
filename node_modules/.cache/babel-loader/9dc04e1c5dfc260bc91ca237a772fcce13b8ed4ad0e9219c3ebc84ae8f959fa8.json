{"ast":null,"code":"\"use strict\";\n\n/*\n * packedbuffer.js - represent a packed buffer of bytes\n *\n * Copyright © 2014 LG Electronics, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Represents a binary buffer of unsigned bytes that will be parsed in various ways. The buffer\n * can be decoded by reading various lengths of bytes and interpreting them as longs\n * or unsigned bytes, etc. The bytes are interpreted in big-endian (network) format.\n * @constructor\n * @param {string} buffer the binary buffer represented as a string\n */\nvar PackedBuffer = function PackedBuffer(buffer) {\n  this.buffer = buffer;\n  this.index = 0;\n};\n\n/**\n * Return the specified number of signed long integers from the current location in\n * the buffer as an array of numbers and advance the current pointer in the buffer.\n * This method will only return as many longs as are available in the rest of the\n * buffer.\n *\n * @param {number} num The number of longs to return\n * @returns {Array.<number>} the array of signed long integers\n */\nPackedBuffer.prototype.getLongs = function (num) {\n  var result;\n  if (this.buffer && this.index < this.buffer.length) {\n    result = [];\n    for (var i = 0; i < num && this.index + 3 < this.buffer.length; i++) {\n      var longnum = this.buffer[this.index] << 24 | this.buffer[this.index + 1] << 16 | this.buffer[this.index + 2] << 8 | this.buffer[this.index + 3];\n      result.push(longnum);\n      this.index += 4;\n    }\n  }\n  return result;\n};\n\n/**\n * Return a signed long integer from the current location in\n * the buffer as an array of numbers and advance the current pointer in the buffer.\n * This method will only return a long if it is available in the buffer, otherwise\n * it will return undefined.\n *\n * @returns {number} the long at the current point in the buffer, or undefined if\n * there is not enough bytes left in the buffer to form a long\n */\nPackedBuffer.prototype.getLong = function () {\n  var longs = this.getLongs(1);\n  if (longs && longs.length > 0) {\n    return longs[0];\n  }\n};\n\n/**\n * Return the specified number of signed byte integers from the current location in\n * the buffer as an array of numbers and advance the current pointer in the buffer.\n * This method will only return as many bytes as are available in the rest of the\n * buffer.\n *\n * @param {number|undefined} num The number of bytes to return\n * @returns {Array.<number>} the array of signed byte integers\n */\nPackedBuffer.prototype.getBytes = function (num) {\n  var result;\n  if (this.buffer && this.index < this.buffer.length) {\n    result = [];\n    for (var i = 0; i < num && this.index < this.buffer.length; i++) {\n      var bytenum = this.buffer[this.index++];\n      if (bytenum & 0x80) {\n        bytenum -= 0x100;\n      }\n      result.push(bytenum);\n    }\n  }\n  return result;\n};\n\n/**\n * Return a signed byte integer from the current location in\n * the buffer as an array of numbers and advance the current pointer in the buffer.\n * This method will only return a byte if it is available in the buffer, otherwise\n * it will return undefined.\n *\n * @returns {number} the byte at the current point in the buffer, or undefined if\n * there is not enough bytes left in the buffer to form a byte\n */\nPackedBuffer.prototype.getByte = function () {\n  var bytes = this.getBytes(1);\n  if (bytes && bytes.length > 0) {\n    return bytes[0];\n  }\n};\n\n/**\n * Return the specified number of unsigned byte integers from the current location in\n * the buffer as an array of numbers and advance the current pointer in the buffer.\n * This method will only return as many bytes as are available in the rest of the\n * buffer.\n *\n * @param {number} num The number of bytes to return\n * @returns {Array.<number>} the array of unsigned byte integers\n */\nPackedBuffer.prototype.getUnsignedBytes = function (num) {\n  var result;\n  if (this.buffer && this.index < this.buffer.length) {\n    result = [];\n    for (var i = 0; i < num && this.index < this.buffer.length; i++) {\n      result.push(this.buffer[this.index++]);\n    }\n  }\n  return result;\n};\n\n/**\n * Return a string made out of the given number of bytes and convert\n * from UTF-8 to UTF-16.\n *\n * @param {number} num The number of bytes to make a string out of\n * @returns {string} a string made out of the given bytes\n */\nPackedBuffer.prototype.getString = function (num) {\n  var arr = this.getUnsignedBytes(num);\n  var str = '';\n  for (var i = 0; i < arr.length; i++) {\n    str += String.fromCharCode(arr[i]);\n  }\n  return str;\n};\n\n/**\n * Advance the current pointer in the buffer by the specified number of\n * bytes in the string.\n *\n * @param {number} num The number of bytes to skip\n * @returns {void}\n */\nPackedBuffer.prototype.skip = function (num) {\n  this.index += num;\n};\nmodule.exports = PackedBuffer;","map":{"version":3,"names":["PackedBuffer","buffer","index","prototype","getLongs","num","result","length","i","longnum","push","getLong","longs","getBytes","bytenum","getByte","bytes","getUnsignedBytes","getString","arr","str","String","fromCharCode","skip","module","exports"],"sources":["/Users/gitchan/Projects/gitchan-yonsei/2024-enact-template/node_modules/@enact/i18n/src/packedbuffer.js"],"sourcesContent":["\"use strict\";\n\n/*\n * packedbuffer.js - represent a packed buffer of bytes\n *\n * Copyright © 2014 LG Electronics, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Represents a binary buffer of unsigned bytes that will be parsed in various ways. The buffer\n * can be decoded by reading various lengths of bytes and interpreting them as longs\n * or unsigned bytes, etc. The bytes are interpreted in big-endian (network) format.\n * @constructor\n * @param {string} buffer the binary buffer represented as a string\n */\nvar PackedBuffer = function PackedBuffer(buffer) {\n  this.buffer = buffer;\n  this.index = 0;\n};\n\n/**\n * Return the specified number of signed long integers from the current location in\n * the buffer as an array of numbers and advance the current pointer in the buffer.\n * This method will only return as many longs as are available in the rest of the\n * buffer.\n *\n * @param {number} num The number of longs to return\n * @returns {Array.<number>} the array of signed long integers\n */\nPackedBuffer.prototype.getLongs = function (num) {\n  var result;\n  if (this.buffer && this.index < this.buffer.length) {\n    result = [];\n    for (var i = 0; i < num && this.index + 3 < this.buffer.length; i++) {\n      var longnum = this.buffer[this.index] << 24 | this.buffer[this.index + 1] << 16 | this.buffer[this.index + 2] << 8 | this.buffer[this.index + 3];\n      result.push(longnum);\n      this.index += 4;\n    }\n  }\n  return result;\n};\n\n/**\n * Return a signed long integer from the current location in\n * the buffer as an array of numbers and advance the current pointer in the buffer.\n * This method will only return a long if it is available in the buffer, otherwise\n * it will return undefined.\n *\n * @returns {number} the long at the current point in the buffer, or undefined if\n * there is not enough bytes left in the buffer to form a long\n */\nPackedBuffer.prototype.getLong = function () {\n  var longs = this.getLongs(1);\n  if (longs && longs.length > 0) {\n    return longs[0];\n  }\n};\n\n/**\n * Return the specified number of signed byte integers from the current location in\n * the buffer as an array of numbers and advance the current pointer in the buffer.\n * This method will only return as many bytes as are available in the rest of the\n * buffer.\n *\n * @param {number|undefined} num The number of bytes to return\n * @returns {Array.<number>} the array of signed byte integers\n */\nPackedBuffer.prototype.getBytes = function (num) {\n  var result;\n  if (this.buffer && this.index < this.buffer.length) {\n    result = [];\n    for (var i = 0; i < num && this.index < this.buffer.length; i++) {\n      var bytenum = this.buffer[this.index++];\n      if (bytenum & 0x80) {\n        bytenum -= 0x100;\n      }\n      result.push(bytenum);\n    }\n  }\n  return result;\n};\n\n/**\n * Return a signed byte integer from the current location in\n * the buffer as an array of numbers and advance the current pointer in the buffer.\n * This method will only return a byte if it is available in the buffer, otherwise\n * it will return undefined.\n *\n * @returns {number} the byte at the current point in the buffer, or undefined if\n * there is not enough bytes left in the buffer to form a byte\n */\nPackedBuffer.prototype.getByte = function () {\n  var bytes = this.getBytes(1);\n  if (bytes && bytes.length > 0) {\n    return bytes[0];\n  }\n};\n\n/**\n * Return the specified number of unsigned byte integers from the current location in\n * the buffer as an array of numbers and advance the current pointer in the buffer.\n * This method will only return as many bytes as are available in the rest of the\n * buffer.\n *\n * @param {number} num The number of bytes to return\n * @returns {Array.<number>} the array of unsigned byte integers\n */\nPackedBuffer.prototype.getUnsignedBytes = function (num) {\n  var result;\n  if (this.buffer && this.index < this.buffer.length) {\n    result = [];\n    for (var i = 0; i < num && this.index < this.buffer.length; i++) {\n      result.push(this.buffer[this.index++]);\n    }\n  }\n  return result;\n};\n\n/**\n * Return a string made out of the given number of bytes and convert\n * from UTF-8 to UTF-16.\n *\n * @param {number} num The number of bytes to make a string out of\n * @returns {string} a string made out of the given bytes\n */\nPackedBuffer.prototype.getString = function (num) {\n  var arr = this.getUnsignedBytes(num);\n  var str = '';\n  for (var i = 0; i < arr.length; i++) {\n    str += String.fromCharCode(arr[i]);\n  }\n  return str;\n};\n\n/**\n * Advance the current pointer in the buffer by the specified number of\n * bytes in the string.\n *\n * @param {number} num The number of bytes to skip\n * @returns {void}\n */\nPackedBuffer.prototype.skip = function (num) {\n  this.index += num;\n};\nmodule.exports = PackedBuffer;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}