{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNavigableTarget = getNavigableTarget;\nexports.getNearestTargetFromPosition = void 0;\nexports.getTargetByContainer = getTargetByContainer;\nexports.getTargetByDirectionFromElement = getTargetByDirectionFromElement;\nexports.getTargetByDirectionFromPosition = getTargetByDirectionFromPosition;\nexports.getTargetBySelector = getTargetBySelector;\nexports.isFocusable = isFocusable;\nvar _clamp = _interopRequireDefault(require(\"ramda/src/clamp\"));\nvar _last = _interopRequireDefault(require(\"ramda/src/last\"));\nvar _container = require(\"./container\");\nvar _navigate = _interopRequireDefault(require(\"./navigate\"));\nvar _utils = require(\"./utils\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction isFocusable(elem) {\n  var containers = (0, _container.getContainersForNode)(elem);\n  var verifySelector = true;\n  for (var i = containers.length - 1; i >= 0; i--) {\n    var containerId = containers[i];\n    if (!(0, _container.isNavigable)(elem, containerId, verifySelector)) {\n      return false;\n    }\n\n    // only verify selector for the first (immediate ancestor) container\n    verifySelector = false;\n  }\n  return true;\n}\nfunction getContainersToSearch(containerId) {\n  var range = [];\n  var addRange = function addRange(id) {\n    var config = (0, _container.getContainerConfig)(id);\n    if (id && range.indexOf(id) < 0 && config && !config.selectorDisabled) {\n      range.push(id);\n    }\n  };\n  if (containerId) {\n    addRange(containerId);\n  } else {\n    addRange((0, _container.getDefaultContainer)());\n    addRange((0, _container.getLastContainer)());\n    _toConsumableArray((0, _container.getAllContainerIds)()).map(addRange);\n  }\n  return range;\n}\nfunction getTargetByContainer(containerId, enterTo) {\n  return getContainersToSearch(containerId).reduce(function (next, id) {\n    return next || (0, _container.getContainerFocusTarget)(id, enterTo);\n  }, null);\n}\nfunction getTargetBySelector(selector) {\n  if (!selector) return null;\n  if (selector.charAt(0) === '@') {\n    var containerId = selector.length === 1 ? null : selector.substr(1);\n    return getTargetByContainer(containerId);\n  }\n  var next = (0, _utils.parseSelector)(selector)[0];\n  if (next) {\n    if ((0, _container.isContainer)(next)) {\n      return getTargetByContainer((0, _container.getContainerId)(next));\n    }\n    var nextContainerIds = (0, _container.getContainersForNode)(next);\n    if ((0, _container.isNavigable)(next, (0, _last[\"default\"])(nextContainerIds), true)) {\n      return next;\n    }\n  }\n  return null;\n}\nfunction isRestrictedContainer(containerId) {\n  var config = (0, _container.getContainerConfig)(containerId);\n  return config && (config.enterTo === 'last-focused' || config.enterTo === 'default-element');\n}\nfunction filterRects(elementRects, boundingRect) {\n  if (!boundingRect) {\n    return elementRects;\n  }\n\n  // remove elements that are outside of boundingRect, if specified\n  return elementRects.filter(function (rect) {\n    if ((0, _container.isContainer)(rect.element)) {\n      // For containers, test intersection since they may be larger than the bounding rect\n      return (0, _utils.intersects)(boundingRect, rect);\n    } else {\n      // For elements, use contains with the center to include mostly visible elements\n      return (0, _utils.contains)(boundingRect, rect.center);\n    }\n  }).map(function (rect) {\n    var topUpdate = rect.top < boundingRect.top;\n    var bottomUpdate = rect.bottom > boundingRect.bottom;\n    var leftUpdate = rect.left < boundingRect.left;\n    var rightUpdate = rect.right > boundingRect.right;\n\n    // if the element's rect is larger than the bounding rect, clamp it to the bounding rect and\n    // recalculate the center based on the new bounds.\n    if (topUpdate || bottomUpdate || leftUpdate || rightUpdate) {\n      var updated = _objectSpread(_objectSpread({}, rect), {}, {\n        center: _objectSpread({}, rect.center)\n      });\n      if (topUpdate) updated.top = boundingRect.top;\n      if (bottomUpdate) updated.bottom = boundingRect.bottom;\n      if (leftUpdate) updated.left = boundingRect.left;\n      if (rightUpdate) updated.right = boundingRect.right;\n      if (leftUpdate || rightUpdate) {\n        var centerX = updated.left + (updated.right - updated.left) / 2;\n        updated.center.x = updated.center.left = updated.center.right = centerX;\n      }\n      if (topUpdate || bottomUpdate) {\n        var centerY = updated.top + (updated.bottom - updated.top) / 2;\n        updated.center.y = updated.center.top = updated.center.bottom = centerY;\n      }\n      return updated;\n    }\n    return rect;\n  });\n}\nfunction getContainerContainingRect(elementRects, elementRect) {\n  // find candidates that are containers and *visually* contain element\n  var overlapping = elementRects.filter(function (rect) {\n    return (0, _container.isContainer)(rect.element) && (0, _utils.contains)(rect, elementRect);\n  });\n\n  // if the next element is a container AND the current element is *visually* contained within\n  // one of the candidate element, we need to ignore container `enterTo` preferences and\n  // retrieve its spottable descendants and try to navigate to them.\n  if (overlapping.length) {\n    return overlapping[0].element.dataset.spotlightId;\n  }\n  return false;\n}\nfunction getOverflowContainerRect(containerId) {\n  // if the target container has overflowing content, update the boundingRect to match its\n  // bounds to prevent finding elements within the container's hierarchy but not visible.\n  // This filter only applies when waterfalling to prevent filtering out elements that share\n  // a container tree with `element`\n  var nextConfig = (0, _container.getContainerConfig)(containerId);\n  if (nextConfig && nextConfig.overflow) {\n    return (0, _utils.getContainerRect)(containerId);\n  }\n}\nfunction getTargetInContainerByDirectionFromPosition(direction, containerId, positionRect, elementContainerIds, boundingRect) {\n  var elements = (0, _container.getDeepSpottableDescendants)(containerId);\n  var elementRects = filterRects((0, _utils.getRects)(elements), boundingRect);\n  var next = null;\n  var _loop = function _loop() {\n    var overlappingContainerId = getContainerContainingRect(elementRects, positionRect);\n\n    // if the pointer is within a container that is a candidate element, we need to ignore container\n    // `enterTo` preferences and retrieve its spottable descendants and try to navigate to them.\n    if (overlappingContainerId) {\n      next = getTargetInContainerByDirectionFromPosition(direction, overlappingContainerId, positionRect, elementContainerIds, boundingRect);\n      if (!next) {\n        // filter out the container and try again\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element.dataset.spotlightId !== overlappingContainerId;\n        });\n        return \"continue\";\n      }\n\n      // found a target so break out and return\n      return \"break\";\n    }\n\n    // try to navigate from position to one of the candidates in containerId\n    next = (0, _navigate[\"default\"])(positionRect, direction, elementRects, (0, _container.getContainerConfig)(containerId));\n\n    // if we match a container, recurse into it\n    if (next && (0, _container.isContainer)(next)) {\n      var nextContainerId = next.dataset.spotlightId;\n\n      // need to cache this reference so we can filter it out later if necessary\n      var lastNavigated = next;\n      next = getTargetInContainerByDirectionFromPosition(direction, nextContainerId, positionRect, elementContainerIds, getOverflowContainerRect(nextContainerId) || boundingRect);\n      if (!next) {\n        // filter out the container and try again\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element !== lastNavigated;\n        });\n        return \"continue\";\n      }\n    }\n\n    // If we've met every condition and haven't explicitly retried the search via `continue`,\n    // break out and return\n    return \"break\";\n  };\n  while (elementRects.length > 0) {\n    var _ret = _loop();\n    if (_ret === \"continue\") continue;\n    if (_ret === \"break\") break;\n  }\n  return next;\n}\nfunction getTargetInContainerByDirectionFromElement(direction, containerId, element, elementRect, elementContainerIds, boundingRect) {\n  var elements = (0, _container.getDeepSpottableDescendants)(containerId);\n\n  // shortcut for previous target from element if it were saved\n  var previous = (0, _container.getContainerPreviousTarget)(containerId, direction, element);\n  if (previous && elements.indexOf(previous) !== -1) {\n    return previous;\n  }\n\n  // `spotlightOverflow` is a private, and likely temporary, API to allow a component within an\n  // spotlight container with `overflow: true` to be treated as if it were outside of the\n  // container. The result is that the candidates, `elements` are filtered by the bounds of the\n  // overflow container effectively hiding those that have overflowed and are visually hidden.\n  //\n  // Currently only used by moonstone/Scroller.Scrollbar as a means to allow 5-way navigation to\n  // escape the Scrollable from paging controls rather than focusing contents that are out of view\n  if (element.dataset.spotlightOverflow === 'ignore') {\n    boundingRect = getOverflowContainerRect(containerId) || boundingRect;\n  }\n  var elementRects = filterRects((0, _utils.getRects)(elements), boundingRect);\n  var next = null;\n  var _loop2 = function _loop2() {\n    var overlappingContainerId = getContainerContainingRect(elementRects, elementRect);\n\n    // if the next element is a container AND the current element is *visually* contained within\n    // one of the candidate elements, we need to ignore container `enterTo` preferences and\n    // retrieve its spottable descendants and try to navigate to them.\n    if (overlappingContainerId) {\n      next = getTargetInContainerByDirectionFromElement(direction, overlappingContainerId, element, elementRect, elementContainerIds, boundingRect);\n      if (!next) {\n        // filter out the container and try again\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element.dataset.spotlightId !== overlappingContainerId;\n        });\n        return \"continue\";\n      }\n\n      // found a target so break out and return\n      return \"break\";\n    }\n\n    // If one of the downstream containers is configured for partition, we use that\n    // container's bounds as the partition rect for navigation.\n    var partitionContainer = elementContainerIds.slice(elementContainerIds.indexOf(containerId) + 1).find(function (id) {\n      var cfg = (0, _container.getContainerConfig)(id);\n      return cfg && cfg.partition;\n    });\n    var partitionRect = elementRect;\n    if (partitionContainer) {\n      partitionRect = (0, _utils.getContainerRect)(partitionContainer);\n    }\n\n    // try to navigate from element to one of the candidates in containerId\n    next = (0, _navigate[\"default\"])(elementRect, direction, elementRects, (0, _container.getContainerConfig)(containerId), partitionRect);\n\n    // if we match a container,\n    if (next && (0, _container.isContainer)(next)) {\n      var nextContainerId = next.dataset.spotlightId;\n\n      // need to cache this reference so we can filter it out later if necessary\n      var lastNavigated = next;\n\n      // and it is restricted, return its target\n      if (isRestrictedContainer(nextContainerId)) {\n        next = getTargetByContainer(nextContainerId);\n      } else {\n        // otherwise, recurse into it\n        next = getTargetInContainerByDirectionFromElement(direction, nextContainerId, element, elementRect, elementContainerIds, getOverflowContainerRect(nextContainerId) || boundingRect);\n      }\n      if (!next) {\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element !== lastNavigated;\n        });\n        return \"continue\";\n      }\n    }\n\n    // If we've met every condition and haven't explicitly retried the search via `continue`,\n    // break out and return\n    return \"break\";\n  };\n  while (elementRects.length > 0) {\n    var _ret2 = _loop2();\n    if (_ret2 === \"continue\") continue;\n    if (_ret2 === \"break\") break;\n  }\n  return next;\n}\nfunction getTargetByDirectionFromElement(direction, element) {\n  var extSelector = element.getAttribute('data-spot-' + direction);\n  if (typeof extSelector === 'string') {\n    return getTargetBySelector(extSelector);\n  }\n  var elementRect = (0, _utils.getRect)(element);\n  var next = (0, _container.getNavigableContainersForNode)(element).reduceRight(function (result, containerId, index, elementContainerIds) {\n    result = result || getTargetInContainerByDirectionFromElement(direction, containerId, element, elementRect, elementContainerIds);\n    if (!result) {\n      result = getLeaveForTarget(containerId, direction);\n\n      // To support a `leaveFor` configuration with navigation disallowed in the current\n      // `direction`, we return the current element to prevent further searches for a\n      // target in this reduction.\n      if (result === false) {\n        result = element;\n      }\n    }\n    return result;\n  }, null);\n\n  // if the reduce above returns the original element, it means it hit a `leaveFor` config that\n  // prevents navigation so we enforce that here by returning null.\n  return next !== element ? next : null;\n}\nfunction getTargetByDirectionFromPosition(direction, position, containerId) {\n  var pointerRect = (0, _utils.getPointRect)(position);\n  return (0, _container.getNavigableContainersForNode)((0, _container.getContainerNode)(containerId)).reduceRight(function (result, id, index, elementContainerIds) {\n    return result || getTargetInContainerByDirectionFromPosition(direction, id, pointerRect, elementContainerIds);\n  }, null);\n}\n\n/**\n * Returns the target identified by the selector configured for the container identified by\n * `containerId` for the given `direction`. If the selector is an empty string, the method returns\n * `false` indicating that navigation isn't allowed out of the container in that direction.\n *\n * @param   {String}        containerId  Identifier for a container\n * @param   {String}        direction    Direction to navigate (up, down, left, right)\n *\n * @returns {Node|Boolean}               Target, if found, or `false` if navigation is disallowed\n * @private\n */\nfunction getLeaveForTarget(containerId, direction) {\n  var config = (0, _container.getContainerConfig)(containerId);\n  if (config) {\n    var target = config.restrict !== 'self-only' && config.leaveFor && config.leaveFor[direction];\n    if (typeof target === 'string') {\n      if (target === '') {\n        return false;\n      }\n      return getTargetBySelector(target);\n    }\n    var nextContainerIds = (0, _container.getContainersForNode)(target);\n    if ((0, _container.isNavigable)(target, (0, _last[\"default\"])(nextContainerIds))) {\n      return target;\n    }\n  }\n  return null;\n}\nfunction getNavigableTarget(target) {\n  if (target === document) return null;\n  var parent;\n  while (target && ((0, _container.isContainer)(target) || !isFocusable(target))) {\n    parent = target.parentNode;\n    target = parent === document ? null : parent; // calling isNavigable on document is problematic\n  }\n\n  return target;\n}\nvar getOffsetDistanceToTargetFromPosition = function getOffsetDistanceToTargetFromPosition(distance, direction, _ref, _ref2) {\n  var x = _ref.x,\n    y = _ref.y;\n  var left = _ref2.left,\n    right = _ref2.right,\n    top = _ref2.top,\n    bottom = _ref2.bottom;\n  if (direction === 'left' || direction === 'right') {\n    if (y > bottom) {\n      distance += y - bottom;\n    } else if (y < top) {\n      distance += top - y;\n    }\n  } else if (x > right) {\n    distance += x - right;\n  } else if (x < left) {\n    distance += left - x;\n  }\n  return distance;\n};\nvar getDistanceToTargetFromPosition = function getDistanceToTargetFromPosition(direction, position, elementRect) {\n  var x = position.x,\n    y = position.y;\n  var distance;\n  if (direction === 'left') {\n    distance = x - elementRect.right;\n  } else if (direction === 'right') {\n    distance = elementRect.left - x;\n  } else if (direction === 'up') {\n    distance = y - elementRect.bottom;\n  } else if (direction === 'down') {\n    distance = elementRect.top - y;\n  }\n  return getOffsetDistanceToTargetFromPosition((0, _clamp[\"default\"])(0, Math.abs(distance), distance), direction, position, elementRect);\n};\nvar getNearestTargetsInContainerFromPosition = function getNearestTargetsInContainerFromPosition(position, containerId) {\n  return ['up', 'left', 'right', 'down'].reduce(function (result, direction) {\n    var target = getTargetByDirectionFromPosition(direction, position, containerId);\n    if (target) {\n      result.push({\n        direction: direction,\n        target: target\n      });\n    }\n    return result;\n  }, []);\n};\nvar getNearestTargetInContainerFromPosition = function getNearestTargetInContainerFromPosition(position, containerId) {\n  var targets = getNearestTargetsInContainerFromPosition(position, containerId);\n  if (!targets.length) {\n    return;\n  }\n  targets.forEach(function (item) {\n    var direction = item.direction,\n      target = item.target;\n    item.distance = getDistanceToTargetFromPosition(direction, position, (0, _utils.getRect)(target));\n  });\n  targets.sort(function (a, b) {\n    return a.distance - b.distance;\n  });\n  return targets[0].target;\n};\nvar getNearestTargetFromPosition = function getNearestTargetFromPosition(position, containerId) {\n  return getNavigableTarget(document.elementFromPoint(position.x, position.y)) || getNearestTargetInContainerFromPosition(position, containerId);\n};\nexports.getNearestTargetFromPosition = getNearestTargetFromPosition;","map":{"version":3,"names":["Object","defineProperty","exports","value","getNavigableTarget","getNearestTargetFromPosition","getTargetByContainer","getTargetByDirectionFromElement","getTargetByDirectionFromPosition","getTargetBySelector","isFocusable","_clamp","_interopRequireDefault","require","_last","_container","_navigate","_utils","obj","__esModule","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","_toPropertyKey","configurable","writable","arg","_toPrimitive","String","input","hint","prim","Symbol","toPrimitive","undefined","res","call","TypeError","Number","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","o","minLen","_arrayLikeToArray","n","prototype","toString","slice","constructor","name","Array","from","test","iter","iterator","isArray","len","arr2","elem","containers","getContainersForNode","verifySelector","containerId","isNavigable","getContainersToSearch","range","addRange","id","config","getContainerConfig","indexOf","selectorDisabled","getDefaultContainer","getLastContainer","getAllContainerIds","map","enterTo","reduce","next","getContainerFocusTarget","selector","charAt","substr","parseSelector","isContainer","getContainerId","nextContainerIds","isRestrictedContainer","filterRects","elementRects","boundingRect","rect","element","intersects","contains","center","topUpdate","top","bottomUpdate","bottom","leftUpdate","left","rightUpdate","right","updated","centerX","x","centerY","y","getContainerContainingRect","elementRect","overlapping","dataset","spotlightId","getOverflowContainerRect","nextConfig","overflow","getContainerRect","getTargetInContainerByDirectionFromPosition","direction","positionRect","elementContainerIds","elements","getDeepSpottableDescendants","getRects","_loop","overlappingContainerId","nextContainerId","lastNavigated","_ret","getTargetInContainerByDirectionFromElement","previous","getContainerPreviousTarget","spotlightOverflow","_loop2","partitionContainer","find","cfg","partition","partitionRect","_ret2","extSelector","getAttribute","getRect","getNavigableContainersForNode","reduceRight","result","index","getLeaveForTarget","position","pointerRect","getPointRect","getContainerNode","restrict","leaveFor","document","parent","parentNode","getOffsetDistanceToTargetFromPosition","distance","_ref","_ref2","getDistanceToTargetFromPosition","Math","abs","getNearestTargetsInContainerFromPosition","getNearestTargetInContainerFromPosition","targets","item","sort","a","b","elementFromPoint"],"sources":["/Users/gitchan/Projects/gitchan-yonsei/2024-enact-template/node_modules/@enact/spotlight/src/target.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNavigableTarget = getNavigableTarget;\nexports.getNearestTargetFromPosition = void 0;\nexports.getTargetByContainer = getTargetByContainer;\nexports.getTargetByDirectionFromElement = getTargetByDirectionFromElement;\nexports.getTargetByDirectionFromPosition = getTargetByDirectionFromPosition;\nexports.getTargetBySelector = getTargetBySelector;\nexports.isFocusable = isFocusable;\nvar _clamp = _interopRequireDefault(require(\"ramda/src/clamp\"));\nvar _last = _interopRequireDefault(require(\"ramda/src/last\"));\nvar _container = require(\"./container\");\nvar _navigate = _interopRequireDefault(require(\"./navigate\"));\nvar _utils = require(\"./utils\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction isFocusable(elem) {\n  var containers = (0, _container.getContainersForNode)(elem);\n  var verifySelector = true;\n  for (var i = containers.length - 1; i >= 0; i--) {\n    var containerId = containers[i];\n    if (!(0, _container.isNavigable)(elem, containerId, verifySelector)) {\n      return false;\n    }\n\n    // only verify selector for the first (immediate ancestor) container\n    verifySelector = false;\n  }\n  return true;\n}\nfunction getContainersToSearch(containerId) {\n  var range = [];\n  var addRange = function addRange(id) {\n    var config = (0, _container.getContainerConfig)(id);\n    if (id && range.indexOf(id) < 0 && config && !config.selectorDisabled) {\n      range.push(id);\n    }\n  };\n  if (containerId) {\n    addRange(containerId);\n  } else {\n    addRange((0, _container.getDefaultContainer)());\n    addRange((0, _container.getLastContainer)());\n    _toConsumableArray((0, _container.getAllContainerIds)()).map(addRange);\n  }\n  return range;\n}\nfunction getTargetByContainer(containerId, enterTo) {\n  return getContainersToSearch(containerId).reduce(function (next, id) {\n    return next || (0, _container.getContainerFocusTarget)(id, enterTo);\n  }, null);\n}\nfunction getTargetBySelector(selector) {\n  if (!selector) return null;\n  if (selector.charAt(0) === '@') {\n    var containerId = selector.length === 1 ? null : selector.substr(1);\n    return getTargetByContainer(containerId);\n  }\n  var next = (0, _utils.parseSelector)(selector)[0];\n  if (next) {\n    if ((0, _container.isContainer)(next)) {\n      return getTargetByContainer((0, _container.getContainerId)(next));\n    }\n    var nextContainerIds = (0, _container.getContainersForNode)(next);\n    if ((0, _container.isNavigable)(next, (0, _last[\"default\"])(nextContainerIds), true)) {\n      return next;\n    }\n  }\n  return null;\n}\nfunction isRestrictedContainer(containerId) {\n  var config = (0, _container.getContainerConfig)(containerId);\n  return config && (config.enterTo === 'last-focused' || config.enterTo === 'default-element');\n}\nfunction filterRects(elementRects, boundingRect) {\n  if (!boundingRect) {\n    return elementRects;\n  }\n\n  // remove elements that are outside of boundingRect, if specified\n  return elementRects.filter(function (rect) {\n    if ((0, _container.isContainer)(rect.element)) {\n      // For containers, test intersection since they may be larger than the bounding rect\n      return (0, _utils.intersects)(boundingRect, rect);\n    } else {\n      // For elements, use contains with the center to include mostly visible elements\n      return (0, _utils.contains)(boundingRect, rect.center);\n    }\n  }).map(function (rect) {\n    var topUpdate = rect.top < boundingRect.top;\n    var bottomUpdate = rect.bottom > boundingRect.bottom;\n    var leftUpdate = rect.left < boundingRect.left;\n    var rightUpdate = rect.right > boundingRect.right;\n\n    // if the element's rect is larger than the bounding rect, clamp it to the bounding rect and\n    // recalculate the center based on the new bounds.\n    if (topUpdate || bottomUpdate || leftUpdate || rightUpdate) {\n      var updated = _objectSpread(_objectSpread({}, rect), {}, {\n        center: _objectSpread({}, rect.center)\n      });\n      if (topUpdate) updated.top = boundingRect.top;\n      if (bottomUpdate) updated.bottom = boundingRect.bottom;\n      if (leftUpdate) updated.left = boundingRect.left;\n      if (rightUpdate) updated.right = boundingRect.right;\n      if (leftUpdate || rightUpdate) {\n        var centerX = updated.left + (updated.right - updated.left) / 2;\n        updated.center.x = updated.center.left = updated.center.right = centerX;\n      }\n      if (topUpdate || bottomUpdate) {\n        var centerY = updated.top + (updated.bottom - updated.top) / 2;\n        updated.center.y = updated.center.top = updated.center.bottom = centerY;\n      }\n      return updated;\n    }\n    return rect;\n  });\n}\nfunction getContainerContainingRect(elementRects, elementRect) {\n  // find candidates that are containers and *visually* contain element\n  var overlapping = elementRects.filter(function (rect) {\n    return (0, _container.isContainer)(rect.element) && (0, _utils.contains)(rect, elementRect);\n  });\n\n  // if the next element is a container AND the current element is *visually* contained within\n  // one of the candidate element, we need to ignore container `enterTo` preferences and\n  // retrieve its spottable descendants and try to navigate to them.\n  if (overlapping.length) {\n    return overlapping[0].element.dataset.spotlightId;\n  }\n  return false;\n}\nfunction getOverflowContainerRect(containerId) {\n  // if the target container has overflowing content, update the boundingRect to match its\n  // bounds to prevent finding elements within the container's hierarchy but not visible.\n  // This filter only applies when waterfalling to prevent filtering out elements that share\n  // a container tree with `element`\n  var nextConfig = (0, _container.getContainerConfig)(containerId);\n  if (nextConfig && nextConfig.overflow) {\n    return (0, _utils.getContainerRect)(containerId);\n  }\n}\nfunction getTargetInContainerByDirectionFromPosition(direction, containerId, positionRect, elementContainerIds, boundingRect) {\n  var elements = (0, _container.getDeepSpottableDescendants)(containerId);\n  var elementRects = filterRects((0, _utils.getRects)(elements), boundingRect);\n  var next = null;\n  var _loop = function _loop() {\n    var overlappingContainerId = getContainerContainingRect(elementRects, positionRect);\n\n    // if the pointer is within a container that is a candidate element, we need to ignore container\n    // `enterTo` preferences and retrieve its spottable descendants and try to navigate to them.\n    if (overlappingContainerId) {\n      next = getTargetInContainerByDirectionFromPosition(direction, overlappingContainerId, positionRect, elementContainerIds, boundingRect);\n      if (!next) {\n        // filter out the container and try again\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element.dataset.spotlightId !== overlappingContainerId;\n        });\n        return \"continue\";\n      }\n\n      // found a target so break out and return\n      return \"break\";\n    }\n\n    // try to navigate from position to one of the candidates in containerId\n    next = (0, _navigate[\"default\"])(positionRect, direction, elementRects, (0, _container.getContainerConfig)(containerId));\n\n    // if we match a container, recurse into it\n    if (next && (0, _container.isContainer)(next)) {\n      var nextContainerId = next.dataset.spotlightId;\n\n      // need to cache this reference so we can filter it out later if necessary\n      var lastNavigated = next;\n      next = getTargetInContainerByDirectionFromPosition(direction, nextContainerId, positionRect, elementContainerIds, getOverflowContainerRect(nextContainerId) || boundingRect);\n      if (!next) {\n        // filter out the container and try again\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element !== lastNavigated;\n        });\n        return \"continue\";\n      }\n    }\n\n    // If we've met every condition and haven't explicitly retried the search via `continue`,\n    // break out and return\n    return \"break\";\n  };\n  while (elementRects.length > 0) {\n    var _ret = _loop();\n    if (_ret === \"continue\") continue;\n    if (_ret === \"break\") break;\n  }\n  return next;\n}\nfunction getTargetInContainerByDirectionFromElement(direction, containerId, element, elementRect, elementContainerIds, boundingRect) {\n  var elements = (0, _container.getDeepSpottableDescendants)(containerId);\n\n  // shortcut for previous target from element if it were saved\n  var previous = (0, _container.getContainerPreviousTarget)(containerId, direction, element);\n  if (previous && elements.indexOf(previous) !== -1) {\n    return previous;\n  }\n\n  // `spotlightOverflow` is a private, and likely temporary, API to allow a component within an\n  // spotlight container with `overflow: true` to be treated as if it were outside of the\n  // container. The result is that the candidates, `elements` are filtered by the bounds of the\n  // overflow container effectively hiding those that have overflowed and are visually hidden.\n  //\n  // Currently only used by moonstone/Scroller.Scrollbar as a means to allow 5-way navigation to\n  // escape the Scrollable from paging controls rather than focusing contents that are out of view\n  if (element.dataset.spotlightOverflow === 'ignore') {\n    boundingRect = getOverflowContainerRect(containerId) || boundingRect;\n  }\n  var elementRects = filterRects((0, _utils.getRects)(elements), boundingRect);\n  var next = null;\n  var _loop2 = function _loop2() {\n    var overlappingContainerId = getContainerContainingRect(elementRects, elementRect);\n\n    // if the next element is a container AND the current element is *visually* contained within\n    // one of the candidate elements, we need to ignore container `enterTo` preferences and\n    // retrieve its spottable descendants and try to navigate to them.\n    if (overlappingContainerId) {\n      next = getTargetInContainerByDirectionFromElement(direction, overlappingContainerId, element, elementRect, elementContainerIds, boundingRect);\n      if (!next) {\n        // filter out the container and try again\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element.dataset.spotlightId !== overlappingContainerId;\n        });\n        return \"continue\";\n      }\n\n      // found a target so break out and return\n      return \"break\";\n    }\n\n    // If one of the downstream containers is configured for partition, we use that\n    // container's bounds as the partition rect for navigation.\n    var partitionContainer = elementContainerIds.slice(elementContainerIds.indexOf(containerId) + 1).find(function (id) {\n      var cfg = (0, _container.getContainerConfig)(id);\n      return cfg && cfg.partition;\n    });\n    var partitionRect = elementRect;\n    if (partitionContainer) {\n      partitionRect = (0, _utils.getContainerRect)(partitionContainer);\n    }\n\n    // try to navigate from element to one of the candidates in containerId\n    next = (0, _navigate[\"default\"])(elementRect, direction, elementRects, (0, _container.getContainerConfig)(containerId), partitionRect);\n\n    // if we match a container,\n    if (next && (0, _container.isContainer)(next)) {\n      var nextContainerId = next.dataset.spotlightId;\n\n      // need to cache this reference so we can filter it out later if necessary\n      var lastNavigated = next;\n\n      // and it is restricted, return its target\n      if (isRestrictedContainer(nextContainerId)) {\n        next = getTargetByContainer(nextContainerId);\n      } else {\n        // otherwise, recurse into it\n        next = getTargetInContainerByDirectionFromElement(direction, nextContainerId, element, elementRect, elementContainerIds, getOverflowContainerRect(nextContainerId) || boundingRect);\n      }\n      if (!next) {\n        elementRects = elementRects.filter(function (rect) {\n          return rect.element !== lastNavigated;\n        });\n        return \"continue\";\n      }\n    }\n\n    // If we've met every condition and haven't explicitly retried the search via `continue`,\n    // break out and return\n    return \"break\";\n  };\n  while (elementRects.length > 0) {\n    var _ret2 = _loop2();\n    if (_ret2 === \"continue\") continue;\n    if (_ret2 === \"break\") break;\n  }\n  return next;\n}\nfunction getTargetByDirectionFromElement(direction, element) {\n  var extSelector = element.getAttribute('data-spot-' + direction);\n  if (typeof extSelector === 'string') {\n    return getTargetBySelector(extSelector);\n  }\n  var elementRect = (0, _utils.getRect)(element);\n  var next = (0, _container.getNavigableContainersForNode)(element).reduceRight(function (result, containerId, index, elementContainerIds) {\n    result = result || getTargetInContainerByDirectionFromElement(direction, containerId, element, elementRect, elementContainerIds);\n    if (!result) {\n      result = getLeaveForTarget(containerId, direction);\n\n      // To support a `leaveFor` configuration with navigation disallowed in the current\n      // `direction`, we return the current element to prevent further searches for a\n      // target in this reduction.\n      if (result === false) {\n        result = element;\n      }\n    }\n    return result;\n  }, null);\n\n  // if the reduce above returns the original element, it means it hit a `leaveFor` config that\n  // prevents navigation so we enforce that here by returning null.\n  return next !== element ? next : null;\n}\nfunction getTargetByDirectionFromPosition(direction, position, containerId) {\n  var pointerRect = (0, _utils.getPointRect)(position);\n  return (0, _container.getNavigableContainersForNode)((0, _container.getContainerNode)(containerId)).reduceRight(function (result, id, index, elementContainerIds) {\n    return result || getTargetInContainerByDirectionFromPosition(direction, id, pointerRect, elementContainerIds);\n  }, null);\n}\n\n/**\n * Returns the target identified by the selector configured for the container identified by\n * `containerId` for the given `direction`. If the selector is an empty string, the method returns\n * `false` indicating that navigation isn't allowed out of the container in that direction.\n *\n * @param   {String}        containerId  Identifier for a container\n * @param   {String}        direction    Direction to navigate (up, down, left, right)\n *\n * @returns {Node|Boolean}               Target, if found, or `false` if navigation is disallowed\n * @private\n */\nfunction getLeaveForTarget(containerId, direction) {\n  var config = (0, _container.getContainerConfig)(containerId);\n  if (config) {\n    var target = config.restrict !== 'self-only' && config.leaveFor && config.leaveFor[direction];\n    if (typeof target === 'string') {\n      if (target === '') {\n        return false;\n      }\n      return getTargetBySelector(target);\n    }\n    var nextContainerIds = (0, _container.getContainersForNode)(target);\n    if ((0, _container.isNavigable)(target, (0, _last[\"default\"])(nextContainerIds))) {\n      return target;\n    }\n  }\n  return null;\n}\nfunction getNavigableTarget(target) {\n  if (target === document) return null;\n  var parent;\n  while (target && ((0, _container.isContainer)(target) || !isFocusable(target))) {\n    parent = target.parentNode;\n    target = parent === document ? null : parent; // calling isNavigable on document is problematic\n  }\n\n  return target;\n}\nvar getOffsetDistanceToTargetFromPosition = function getOffsetDistanceToTargetFromPosition(distance, direction, _ref, _ref2) {\n  var x = _ref.x,\n    y = _ref.y;\n  var left = _ref2.left,\n    right = _ref2.right,\n    top = _ref2.top,\n    bottom = _ref2.bottom;\n  if (direction === 'left' || direction === 'right') {\n    if (y > bottom) {\n      distance += y - bottom;\n    } else if (y < top) {\n      distance += top - y;\n    }\n  } else if (x > right) {\n    distance += x - right;\n  } else if (x < left) {\n    distance += left - x;\n  }\n  return distance;\n};\nvar getDistanceToTargetFromPosition = function getDistanceToTargetFromPosition(direction, position, elementRect) {\n  var x = position.x,\n    y = position.y;\n  var distance;\n  if (direction === 'left') {\n    distance = x - elementRect.right;\n  } else if (direction === 'right') {\n    distance = elementRect.left - x;\n  } else if (direction === 'up') {\n    distance = y - elementRect.bottom;\n  } else if (direction === 'down') {\n    distance = elementRect.top - y;\n  }\n  return getOffsetDistanceToTargetFromPosition((0, _clamp[\"default\"])(0, Math.abs(distance), distance), direction, position, elementRect);\n};\nvar getNearestTargetsInContainerFromPosition = function getNearestTargetsInContainerFromPosition(position, containerId) {\n  return ['up', 'left', 'right', 'down'].reduce(function (result, direction) {\n    var target = getTargetByDirectionFromPosition(direction, position, containerId);\n    if (target) {\n      result.push({\n        direction: direction,\n        target: target\n      });\n    }\n    return result;\n  }, []);\n};\nvar getNearestTargetInContainerFromPosition = function getNearestTargetInContainerFromPosition(position, containerId) {\n  var targets = getNearestTargetsInContainerFromPosition(position, containerId);\n  if (!targets.length) {\n    return;\n  }\n  targets.forEach(function (item) {\n    var direction = item.direction,\n      target = item.target;\n    item.distance = getDistanceToTargetFromPosition(direction, position, (0, _utils.getRect)(target));\n  });\n  targets.sort(function (a, b) {\n    return a.distance - b.distance;\n  });\n  return targets[0].target;\n};\nvar getNearestTargetFromPosition = function getNearestTargetFromPosition(position, containerId) {\n  return getNavigableTarget(document.elementFromPoint(position.x, position.y)) || getNearestTargetInContainerFromPosition(position, containerId);\n};\nexports.getNearestTargetFromPosition = getNearestTargetFromPosition;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}