{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nexports.navigate = navigate;\nvar obliqueMinDistance = 1;\nvar straightMinDistance = 0;\nvar calcGroupId = function calcGroupId(_ref) {\n  var x = _ref.x,\n    y = _ref.y;\n  return y * 3 + x;\n};\nvar calcNextGridPosition = function calcNextGridPosition(current, next) {\n  var center = current.center;\n  var x, y;\n  if (center.x < next.left) {\n    x = 0;\n  } else if (center.x <= next.right) {\n    x = 1;\n  } else {\n    x = 2;\n  }\n  if (center.y < next.top) {\n    y = 0;\n  } else if (center.y <= next.bottom) {\n    y = 1;\n  } else {\n    y = 2;\n  }\n  return {\n    x: x,\n    y: y\n  };\n};\nvar calcNextExtendedGridPosition = function calcNextExtendedGridPosition(current, next) {\n  var x, y;\n  if (current.right <= next.left) {\n    x = 0;\n  } else if (current.left < next.right) {\n    x = 1;\n  } else {\n    x = 2;\n  }\n  if (current.bottom <= next.top) {\n    y = 0;\n  } else if (current.top < next.bottom) {\n    y = 1;\n  } else {\n    y = 2;\n  }\n  return {\n    x: x,\n    y: y\n  };\n};\nfunction prioritize(priorities, targetEdge) {\n  var destGroup = [];\n  var _loop = function _loop() {\n    var destPriority = priorities[index];\n    if (destPriority.group.length) {\n      var destDistance = destPriority.distance;\n      var destDifference = destPriority.difference;\n      var distance = 0;\n      var target;\n      destPriority.group.sort(function (a, b) {\n        for (var i = 0; i < destDistance.length; i++) {\n          var calcDistance = destDistance[i];\n          var delta = calcDistance(a) - calcDistance(b);\n          if (delta) {\n            return delta;\n          }\n        }\n        return 0;\n      });\n      target = destPriority.group[0];\n      for (var i = 0; i < destDifference.length; i++) {\n        distance += destDifference[i](target);\n      }\n      destGroup.push({\n        distance: Math.pow(destPriority.multiplier * (distance || destPriority.minDistance) / targetEdge, 2) + targetEdge,\n        target: target\n      });\n    }\n  };\n  for (var index = 0; index < priorities.length; index++) {\n    _loop();\n  }\n  if (!destGroup.length) {\n    return null;\n  }\n  destGroup.sort(function (a, b) {\n    return a.distance - b.distance;\n  });\n  return destGroup;\n}\nfunction partition(rects, targetRect, straightOverlapThreshold, getGroupId) {\n  // a matrix of elements where the center of the element in relation to targetRect is:\n  var groups = [[/* [0] => above/left */], [/* [1] => above/within */], [/* [2] => above/right */], [/* [3] => within/left */], [/* [4] => within */], [/* [5] => within/right */], [/* [6] => below/left */], [/* [7] => below and within */], [/* [8] => below/right */]];\n  for (var i = 0; i < rects.length; i++) {\n    var rect = rects[i];\n    var groupId = getGroupId(rect, targetRect);\n    groups[groupId].push(rect);\n    if ([0, 2, 6, 8].indexOf(groupId) !== -1) {\n      if (rect.left <= targetRect.right - targetRect.width * straightOverlapThreshold) {\n        if (groupId === 2) {\n          groups[1].push(rect);\n        } else if (groupId === 8) {\n          groups[7].push(rect);\n        }\n      }\n      if (rect.right >= targetRect.left + targetRect.width * straightOverlapThreshold) {\n        if (groupId === 0) {\n          groups[1].push(rect);\n        } else if (groupId === 6) {\n          groups[7].push(rect);\n        }\n      }\n      if (rect.top <= targetRect.bottom - targetRect.height * straightOverlapThreshold) {\n        if (groupId === 6) {\n          groups[3].push(rect);\n        } else if (groupId === 8) {\n          groups[5].push(rect);\n        }\n      }\n      if (rect.bottom >= targetRect.top + targetRect.height * straightOverlapThreshold) {\n        if (groupId === 0) {\n          groups[3].push(rect);\n        } else if (groupId === 2) {\n          groups[5].push(rect);\n        }\n      }\n    }\n  }\n  return groups;\n}\nfunction generateDistancefunction(targetRect) {\n  return {\n    nearPlumbLineIsBetter: function nearPlumbLineIsBetter(rect) {\n      var d;\n      if (rect.center.x < targetRect.center.x) {\n        d = targetRect.center.x - rect.right;\n      } else {\n        d = rect.left - targetRect.center.x;\n      }\n      return d < 0 ? 0 : d;\n    },\n    nearHorizonIsBetter: function nearHorizonIsBetter(rect) {\n      var d;\n      if (rect.center.y < targetRect.center.y) {\n        d = targetRect.center.y - rect.bottom;\n      } else {\n        d = rect.top - targetRect.center.y;\n      }\n      return d < 0 ? 0 : d;\n    },\n    nearTargetBottomIsBetter: function nearTargetBottomIsBetter(rect) {\n      var d;\n      if (rect.center.y < targetRect.center.y) {\n        d = targetRect.bottom - rect.top;\n      } else {\n        d = rect.top - targetRect.bottom;\n      }\n      return d < 0 ? 0 : d;\n    },\n    nearTargetLeftIsBetter: function nearTargetLeftIsBetter(rect) {\n      var d;\n      if (rect.center.x < targetRect.center.x) {\n        d = targetRect.left - rect.right;\n      } else {\n        d = rect.left - targetRect.left;\n      }\n      return d < 0 ? 0 : d;\n    },\n    nearTargetRightIsBetter: function nearTargetRightIsBetter(rect) {\n      var d;\n      if (rect.center.x < targetRect.center.x) {\n        d = targetRect.right - rect.left;\n      } else {\n        d = rect.left - targetRect.right;\n      }\n      return d < 0 ? 0 : d;\n    },\n    nearTargetTopIsBetter: function nearTargetTopIsBetter(rect) {\n      var d;\n      if (rect.center.y < targetRect.center.y) {\n        d = targetRect.top - rect.bottom;\n      } else {\n        d = rect.top - targetRect.top;\n      }\n      return d < 0 ? 0 : d;\n    },\n    topIsBetter: function topIsBetter(rect) {\n      return rect.top;\n    },\n    bottomIsBetter: function bottomIsBetter(rect) {\n      return -1 * rect.bottom;\n    },\n    leftIsBetter: function leftIsBetter(rect) {\n      return rect.left;\n    },\n    rightIsBetter: function rightIsBetter(rect) {\n      return -1 * rect.right;\n    }\n  };\n}\nfunction navigate(targetRect, direction, rects, config) {\n  var partitionRect = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : targetRect;\n  if (!targetRect || !direction || !rects || !rects.length || !config) {\n    return null;\n  }\n  var distanceFunction = generateDistancefunction(targetRect);\n  var obliqueMultiplier = config.obliqueMultiplier,\n    straightMultiplier = config.straightMultiplier,\n    straightOnly = config.straightOnly,\n    straightOverlapThreshold = config.straightOverlapThreshold;\n  var groups = partition(rects, partitionRect, straightOverlapThreshold, function (rect, destRect) {\n    return calcGroupId(direction === 'up' || direction === 'down' ? calcNextExtendedGridPosition(rect, destRect) : calcNextGridPosition(rect, destRect));\n  });\n  var internalGroups = partition(groups[4], targetRect.center, straightOverlapThreshold, function (rect, destRect) {\n    return calcGroupId(calcNextGridPosition(rect, destRect));\n  });\n  var priorities, targetEdge;\n  switch (direction) {\n    case 'left':\n      targetEdge = direction;\n      priorities = [{\n        group: internalGroups[0].concat(internalGroups[3]).concat(internalGroups[6]),\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.nearHorizonIsBetter, distanceFunction.topIsBetter],\n        difference: [distanceFunction.nearTargetLeftIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[3],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.nearHorizonIsBetter, distanceFunction.topIsBetter],\n        difference: [distanceFunction.nearTargetLeftIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[0],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.rightIsBetter, distanceFunction.nearTargetTopIsBetter],\n        difference: [distanceFunction.nearTargetLeftIsBetter, distanceFunction.nearTargetTopIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }, {\n        group: groups[6],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.rightIsBetter, distanceFunction.nearTargetTopIsBetter],\n        difference: [distanceFunction.nearTargetLeftIsBetter, distanceFunction.nearTargetBottomIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }];\n      break;\n    case 'right':\n      targetEdge = direction;\n      priorities = [{\n        group: internalGroups[2].concat(internalGroups[5]).concat(internalGroups[8]),\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.nearHorizonIsBetter, distanceFunction.topIsBetter],\n        difference: [distanceFunction.nearTargetRightIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[5],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.nearHorizonIsBetter, distanceFunction.topIsBetter],\n        difference: [distanceFunction.nearTargetRightIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[2],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.leftIsBetter, distanceFunction.nearTargetTopIsBetter],\n        difference: [distanceFunction.nearTargetRightIsBetter, distanceFunction.nearTargetTopIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }, {\n        group: groups[8],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.leftIsBetter, distanceFunction.nearTargetTopIsBetter],\n        difference: [distanceFunction.nearTargetRightIsBetter, distanceFunction.nearTargetBottomIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }];\n      break;\n    case 'up':\n      targetEdge = 'top';\n      priorities = [{\n        group: internalGroups[0].concat(internalGroups[1]).concat(internalGroups[2]),\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.nearPlumbLineIsBetter, distanceFunction.leftIsBetter],\n        difference: [distanceFunction.nearTargetTopIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[1],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.nearPlumbLineIsBetter, distanceFunction.leftIsBetter],\n        difference: [distanceFunction.nearTargetTopIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[0],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.bottomIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        difference: [distanceFunction.nearTargetTopIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }, {\n        group: groups[2],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.bottomIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        difference: [distanceFunction.nearTargetTopIsBetter, distanceFunction.nearTargetRightIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }];\n      break;\n    case 'down':\n      targetEdge = 'bottom';\n      priorities = [{\n        group: internalGroups[6].concat(internalGroups[7]).concat(internalGroups[8]),\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.nearPlumbLineIsBetter, distanceFunction.leftIsBetter],\n        difference: [distanceFunction.nearTargetBottomIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[7],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.nearPlumbLineIsBetter, distanceFunction.leftIsBetter],\n        difference: [distanceFunction.nearTargetBottomIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[6],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.topIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        difference: [distanceFunction.nearTargetBottomIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }, {\n        group: groups[8],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.topIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        difference: [distanceFunction.nearTargetBottomIsBetter, distanceFunction.nearTargetRightIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }];\n      break;\n    default:\n      return null;\n  }\n  if (straightOnly) {\n    priorities.splice(2, 2);\n  }\n  var destGroup = prioritize(priorities, targetRect[targetEdge]);\n  if (!destGroup) {\n    return null;\n  }\n  return destGroup[0].target.element;\n}\nvar _default = navigate;\nexports[\"default\"] = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","navigate","obliqueMinDistance","straightMinDistance","calcGroupId","_ref","x","y","calcNextGridPosition","current","next","center","left","right","top","bottom","calcNextExtendedGridPosition","prioritize","priorities","targetEdge","destGroup","_loop","destPriority","index","group","length","destDistance","distance","destDifference","difference","target","sort","a","b","i","calcDistance","delta","push","Math","pow","multiplier","minDistance","partition","rects","targetRect","straightOverlapThreshold","getGroupId","groups","rect","groupId","indexOf","width","height","generateDistancefunction","nearPlumbLineIsBetter","d","nearHorizonIsBetter","nearTargetBottomIsBetter","nearTargetLeftIsBetter","nearTargetRightIsBetter","nearTargetTopIsBetter","topIsBetter","bottomIsBetter","leftIsBetter","rightIsBetter","direction","config","partitionRect","arguments","undefined","distanceFunction","obliqueMultiplier","straightMultiplier","straightOnly","destRect","internalGroups","concat","splice","element","_default"],"sources":["/Users/gitchan/Projects/gitchan-yonsei/2024-enact-template/node_modules/@enact/spotlight/src/navigate.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\nexports.navigate = navigate;\nvar obliqueMinDistance = 1;\nvar straightMinDistance = 0;\nvar calcGroupId = function calcGroupId(_ref) {\n  var x = _ref.x,\n    y = _ref.y;\n  return y * 3 + x;\n};\nvar calcNextGridPosition = function calcNextGridPosition(current, next) {\n  var center = current.center;\n  var x, y;\n  if (center.x < next.left) {\n    x = 0;\n  } else if (center.x <= next.right) {\n    x = 1;\n  } else {\n    x = 2;\n  }\n  if (center.y < next.top) {\n    y = 0;\n  } else if (center.y <= next.bottom) {\n    y = 1;\n  } else {\n    y = 2;\n  }\n  return {\n    x: x,\n    y: y\n  };\n};\nvar calcNextExtendedGridPosition = function calcNextExtendedGridPosition(current, next) {\n  var x, y;\n  if (current.right <= next.left) {\n    x = 0;\n  } else if (current.left < next.right) {\n    x = 1;\n  } else {\n    x = 2;\n  }\n  if (current.bottom <= next.top) {\n    y = 0;\n  } else if (current.top < next.bottom) {\n    y = 1;\n  } else {\n    y = 2;\n  }\n  return {\n    x: x,\n    y: y\n  };\n};\nfunction prioritize(priorities, targetEdge) {\n  var destGroup = [];\n  var _loop = function _loop() {\n    var destPriority = priorities[index];\n    if (destPriority.group.length) {\n      var destDistance = destPriority.distance;\n      var destDifference = destPriority.difference;\n      var distance = 0;\n      var target;\n      destPriority.group.sort(function (a, b) {\n        for (var i = 0; i < destDistance.length; i++) {\n          var calcDistance = destDistance[i];\n          var delta = calcDistance(a) - calcDistance(b);\n          if (delta) {\n            return delta;\n          }\n        }\n        return 0;\n      });\n      target = destPriority.group[0];\n      for (var i = 0; i < destDifference.length; i++) {\n        distance += destDifference[i](target);\n      }\n      destGroup.push({\n        distance: Math.pow(destPriority.multiplier * (distance || destPriority.minDistance) / targetEdge, 2) + targetEdge,\n        target: target\n      });\n    }\n  };\n  for (var index = 0; index < priorities.length; index++) {\n    _loop();\n  }\n  if (!destGroup.length) {\n    return null;\n  }\n  destGroup.sort(function (a, b) {\n    return a.distance - b.distance;\n  });\n  return destGroup;\n}\nfunction partition(rects, targetRect, straightOverlapThreshold, getGroupId) {\n  // a matrix of elements where the center of the element in relation to targetRect is:\n  var groups = [[/* [0] => above/left */], [/* [1] => above/within */], [/* [2] => above/right */], [/* [3] => within/left */], [/* [4] => within */], [/* [5] => within/right */], [/* [6] => below/left */], [/* [7] => below and within */], [/* [8] => below/right */]];\n  for (var i = 0; i < rects.length; i++) {\n    var rect = rects[i];\n    var groupId = getGroupId(rect, targetRect);\n    groups[groupId].push(rect);\n    if ([0, 2, 6, 8].indexOf(groupId) !== -1) {\n      if (rect.left <= targetRect.right - targetRect.width * straightOverlapThreshold) {\n        if (groupId === 2) {\n          groups[1].push(rect);\n        } else if (groupId === 8) {\n          groups[7].push(rect);\n        }\n      }\n      if (rect.right >= targetRect.left + targetRect.width * straightOverlapThreshold) {\n        if (groupId === 0) {\n          groups[1].push(rect);\n        } else if (groupId === 6) {\n          groups[7].push(rect);\n        }\n      }\n      if (rect.top <= targetRect.bottom - targetRect.height * straightOverlapThreshold) {\n        if (groupId === 6) {\n          groups[3].push(rect);\n        } else if (groupId === 8) {\n          groups[5].push(rect);\n        }\n      }\n      if (rect.bottom >= targetRect.top + targetRect.height * straightOverlapThreshold) {\n        if (groupId === 0) {\n          groups[3].push(rect);\n        } else if (groupId === 2) {\n          groups[5].push(rect);\n        }\n      }\n    }\n  }\n  return groups;\n}\nfunction generateDistancefunction(targetRect) {\n  return {\n    nearPlumbLineIsBetter: function nearPlumbLineIsBetter(rect) {\n      var d;\n      if (rect.center.x < targetRect.center.x) {\n        d = targetRect.center.x - rect.right;\n      } else {\n        d = rect.left - targetRect.center.x;\n      }\n      return d < 0 ? 0 : d;\n    },\n    nearHorizonIsBetter: function nearHorizonIsBetter(rect) {\n      var d;\n      if (rect.center.y < targetRect.center.y) {\n        d = targetRect.center.y - rect.bottom;\n      } else {\n        d = rect.top - targetRect.center.y;\n      }\n      return d < 0 ? 0 : d;\n    },\n    nearTargetBottomIsBetter: function nearTargetBottomIsBetter(rect) {\n      var d;\n      if (rect.center.y < targetRect.center.y) {\n        d = targetRect.bottom - rect.top;\n      } else {\n        d = rect.top - targetRect.bottom;\n      }\n      return d < 0 ? 0 : d;\n    },\n    nearTargetLeftIsBetter: function nearTargetLeftIsBetter(rect) {\n      var d;\n      if (rect.center.x < targetRect.center.x) {\n        d = targetRect.left - rect.right;\n      } else {\n        d = rect.left - targetRect.left;\n      }\n      return d < 0 ? 0 : d;\n    },\n    nearTargetRightIsBetter: function nearTargetRightIsBetter(rect) {\n      var d;\n      if (rect.center.x < targetRect.center.x) {\n        d = targetRect.right - rect.left;\n      } else {\n        d = rect.left - targetRect.right;\n      }\n      return d < 0 ? 0 : d;\n    },\n    nearTargetTopIsBetter: function nearTargetTopIsBetter(rect) {\n      var d;\n      if (rect.center.y < targetRect.center.y) {\n        d = targetRect.top - rect.bottom;\n      } else {\n        d = rect.top - targetRect.top;\n      }\n      return d < 0 ? 0 : d;\n    },\n    topIsBetter: function topIsBetter(rect) {\n      return rect.top;\n    },\n    bottomIsBetter: function bottomIsBetter(rect) {\n      return -1 * rect.bottom;\n    },\n    leftIsBetter: function leftIsBetter(rect) {\n      return rect.left;\n    },\n    rightIsBetter: function rightIsBetter(rect) {\n      return -1 * rect.right;\n    }\n  };\n}\nfunction navigate(targetRect, direction, rects, config) {\n  var partitionRect = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : targetRect;\n  if (!targetRect || !direction || !rects || !rects.length || !config) {\n    return null;\n  }\n  var distanceFunction = generateDistancefunction(targetRect);\n  var obliqueMultiplier = config.obliqueMultiplier,\n    straightMultiplier = config.straightMultiplier,\n    straightOnly = config.straightOnly,\n    straightOverlapThreshold = config.straightOverlapThreshold;\n  var groups = partition(rects, partitionRect, straightOverlapThreshold, function (rect, destRect) {\n    return calcGroupId(direction === 'up' || direction === 'down' ? calcNextExtendedGridPosition(rect, destRect) : calcNextGridPosition(rect, destRect));\n  });\n  var internalGroups = partition(groups[4], targetRect.center, straightOverlapThreshold, function (rect, destRect) {\n    return calcGroupId(calcNextGridPosition(rect, destRect));\n  });\n  var priorities, targetEdge;\n  switch (direction) {\n    case 'left':\n      targetEdge = direction;\n      priorities = [{\n        group: internalGroups[0].concat(internalGroups[3]).concat(internalGroups[6]),\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.nearHorizonIsBetter, distanceFunction.topIsBetter],\n        difference: [distanceFunction.nearTargetLeftIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[3],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.nearHorizonIsBetter, distanceFunction.topIsBetter],\n        difference: [distanceFunction.nearTargetLeftIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[0],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.rightIsBetter, distanceFunction.nearTargetTopIsBetter],\n        difference: [distanceFunction.nearTargetLeftIsBetter, distanceFunction.nearTargetTopIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }, {\n        group: groups[6],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.rightIsBetter, distanceFunction.nearTargetTopIsBetter],\n        difference: [distanceFunction.nearTargetLeftIsBetter, distanceFunction.nearTargetBottomIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }];\n      break;\n    case 'right':\n      targetEdge = direction;\n      priorities = [{\n        group: internalGroups[2].concat(internalGroups[5]).concat(internalGroups[8]),\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.nearHorizonIsBetter, distanceFunction.topIsBetter],\n        difference: [distanceFunction.nearTargetRightIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[5],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.nearHorizonIsBetter, distanceFunction.topIsBetter],\n        difference: [distanceFunction.nearTargetRightIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[2],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.leftIsBetter, distanceFunction.nearTargetTopIsBetter],\n        difference: [distanceFunction.nearTargetRightIsBetter, distanceFunction.nearTargetTopIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }, {\n        group: groups[8],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.leftIsBetter, distanceFunction.nearTargetTopIsBetter],\n        difference: [distanceFunction.nearTargetRightIsBetter, distanceFunction.nearTargetBottomIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }];\n      break;\n    case 'up':\n      targetEdge = 'top';\n      priorities = [{\n        group: internalGroups[0].concat(internalGroups[1]).concat(internalGroups[2]),\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.nearPlumbLineIsBetter, distanceFunction.leftIsBetter],\n        difference: [distanceFunction.nearTargetTopIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[1],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.nearPlumbLineIsBetter, distanceFunction.leftIsBetter],\n        difference: [distanceFunction.nearTargetTopIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[0],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.bottomIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        difference: [distanceFunction.nearTargetTopIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }, {\n        group: groups[2],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.bottomIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        difference: [distanceFunction.nearTargetTopIsBetter, distanceFunction.nearTargetRightIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }];\n      break;\n    case 'down':\n      targetEdge = 'bottom';\n      priorities = [{\n        group: internalGroups[6].concat(internalGroups[7]).concat(internalGroups[8]),\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.nearPlumbLineIsBetter, distanceFunction.leftIsBetter],\n        difference: [distanceFunction.nearTargetBottomIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[7],\n        distance: [distanceFunction.nearHorizonIsBetter, distanceFunction.nearPlumbLineIsBetter, distanceFunction.leftIsBetter],\n        difference: [distanceFunction.nearTargetBottomIsBetter],\n        minDistance: straightMinDistance,\n        multiplier: straightMultiplier\n      }, {\n        group: groups[6],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.topIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        difference: [distanceFunction.nearTargetBottomIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }, {\n        group: groups[8],\n        distance: [distanceFunction.nearPlumbLineIsBetter, distanceFunction.topIsBetter, distanceFunction.nearTargetLeftIsBetter],\n        difference: [distanceFunction.nearTargetBottomIsBetter, distanceFunction.nearTargetRightIsBetter],\n        minDistance: obliqueMinDistance,\n        multiplier: obliqueMultiplier\n      }];\n      break;\n    default:\n      return null;\n  }\n  if (straightOnly) {\n    priorities.splice(2, 2);\n  }\n  var destGroup = prioritize(priorities, targetRect[targetEdge]);\n  if (!destGroup) {\n    return null;\n  }\n  return destGroup[0].target.element;\n}\nvar _default = navigate;\nexports[\"default\"] = _default;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}