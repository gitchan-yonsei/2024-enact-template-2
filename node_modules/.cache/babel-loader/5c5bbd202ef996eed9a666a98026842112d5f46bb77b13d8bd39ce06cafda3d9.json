{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calculateFontSize = calculateFontSize;\nexports.config = void 0;\nexports.defineScreenTypes = defineScreenTypes;\nexports.getAspectRatio = getAspectRatio;\nexports.getAspectRatioName = getAspectRatioName;\nexports.getResolutionClasses = getResolutionClasses;\nexports.getScreenType = getScreenType;\nexports.getScreenTypeObject = getScreenTypeObject;\nexports.init = init;\nexports.scale = scale;\nexports.scaleToRem = void 0;\nexports.selectSrc = selectSrc;\nexports.unit = unit;\nexports.unitToPixelFactors = void 0;\nvar baseScreen,\n  orientation,\n  riRatio,\n  screenType,\n  workspaceBounds = {\n    width: typeof window === 'object' ? window.innerWidth : 1920,\n    height: typeof window === 'object' ? window.innerHeight : 1080\n  },\n  screenTypes = [{\n    name: 'standard',\n    pxPerRem: 16,\n    width: workspaceBounds.width,\n    height: workspaceBounds.height,\n    aspectRatioName: 'standard',\n    base: true\n  }],\n  // Assign one sane type in case defineScreenTypes is never run.\n  screenTypeObject,\n  config;\n\n/**\n * Object that stores all of the pixel conversion factors to each keyed unit.\n *\n * @type {Object}\n * @memberof ui/resolution\n * @public\n */\nexports.config = config;\nvar unitToPixelFactors = {\n  'rem': 12,\n  'in': 96\n};\nexports.unitToPixelFactors = unitToPixelFactors;\nvar configDefaults = {\n  intermediateScreenHandling: 'normal',\n  matchSmallerScreenType: false,\n  orientationHandling: 'normal'\n};\n\n/**\n * Update the common measured boundary object.\n *\n * This object is used as \"what size screen are we looking at\". Providing no arguments has no\n * effect and updates nothing.\n *\n * @function\n * @memberOf ui/resolution\n * @param {Node}    measurementNode    A standard DOM node or the `window` node.\n *\n * @returns {undefined}\n * @private\n */\nvar updateWorkspaceBounds = function updateWorkspaceBounds(measurementNode) {\n  if (measurementNode && (measurementNode.clientHeight || measurementNode.clientWidth)) {\n    workspaceBounds = {\n      height: measurementNode.clientHeight,\n      width: measurementNode.clientWidth\n    };\n  } else if (measurementNode && (measurementNode.innerHeight || measurementNode.innerWidth)) {\n    // A backup for if measurementNode is actually `window` and not a normal node\n    workspaceBounds = {\n      height: measurementNode.innerHeight,\n      width: measurementNode.innerWidth\n    };\n  }\n};\n\n/**\n * Fetch the screenType object\n *\n * @function\n * @memberof ui/resolution\n * @param  {String}    type    The key string for the screen type object. If falsy, the current\n *                             screenType is used\n *\n * @returns {Object}           screenTypeObject\n * @private\n */\nfunction getScreenTypeObject(type) {\n  type = type || screenType;\n  if (screenTypeObject && screenTypeObject.name === type) {\n    return screenTypeObject;\n  }\n  return screenTypes.filter(function (elem) {\n    return type === elem.name;\n  })[0];\n}\n\n/**\n * Sets up screen resolution scaling capabilities by defining an array of all the screens\n * being used.\n *\n * These should be listed in order from smallest to largest, according to\n * width.\n *\n * The `name`, `pxPerRem`, `width`, and `aspectRatioName` properties are required for\n * each screen type in the array. Setting `base: true` on a screen type marks it as the\n * default resolution, upon which everything else will be based.\n *\n * Executing this method also initializes the rest of the resolution-independence code.\n *\n * Example:\n * ```\n * import ri from 'enact/ui/resolution';\n *\n * ri.defineScreenTypes([\n * \t{name: 'vga',     pxPerRem: 8,  width: 640,  height: 480,  aspectRatioName: 'standard'},\n * \t{name: 'xga',     pxPerRem: 16, width: 1024, height: 768,  aspectRatioName: 'standard'},\n * \t{name: 'hd',      pxPerRem: 16, width: 1280, height: 720,  aspectRatioName: 'hdtv'},\n * \t{name: 'fhd',     pxPerRem: 24, width: 1920, height: 1080, aspectRatioName: 'hdtv', base: true},\n * \t{name: 'uw-uxga', pxPerRem: 24, width: 2560, height: 1080, aspectRatioName: 'cinema'},\n * \t{name: 'uhd',     pxPerRem: 48, width: 3840, height: 2160, aspectRatioName: 'hdtv'}\n * ]);\n * ```\n *\n * @function\n * @memberof ui/resolution\n * @param {Object[]}    types    An array of objects containing screen configuration data, as in the\n *                            preceding example.\n * @returns {undefined}\n * @public\n */\nfunction defineScreenTypes(types) {\n  if (types) screenTypes = types;\n  for (var i = 0; i < screenTypes.length; i++) {\n    if (screenTypes[i]['base']) baseScreen = screenTypes[i];\n  }\n  init();\n}\n\n/**\n * Fetches the name of the screen type that best matches the current screen size.\n *\n * The best match is defined as the screen type that is the closest to the screen resolution without\n * going over. (\"The Price is Right\" style.)\n *\n * @function\n * @memberof ui/resolution\n * @param {Object}    rez    Optional measurement scheme. Must include `height` and `width` properties.\n * @returns {String}         Screen type (e.g., `'fhd'`, `'uhd'`, etc.)\n * @public\n */\nfunction getScreenType(rez) {\n  rez = rez || workspaceBounds;\n  var types = screenTypes;\n  var bestMatch = config.matchSmallerScreenType ? types[0].name : types[types.length - 1].name; // Blindly set the first screen type, in case no matches are found later.\n\n  orientation = 'landscape';\n  if (rez.height > rez.width) {\n    orientation = 'portrait';\n    var swap = rez.width;\n    rez.width = rez.height;\n    rez.height = swap;\n  }\n  if (config.matchSmallerScreenType) {\n    // Loop through resolutions, first->last, smallest->largest\n    for (var i = 0; i <= types.length - 1; i++) {\n      // Does this screenType definition fit inside the current resolution? If so, save it as the current best match.\n      if (rez.height >= types[i].height && rez.width >= types[i].width) {\n        bestMatch = types[i].name;\n      }\n    }\n  } else {\n    // Loop through resolutions, last->first, largest->smallest\n    for (var _i = types.length - 1; _i >= 0; _i--) {\n      // Does the current resolution fit inside this screenType definition? If so, save it as the current best match.\n      if (rez.height <= types[_i].height && rez.width <= types[_i].width) {\n        bestMatch = types[_i].name;\n      }\n    }\n  }\n\n  // Return the name of the closest fitting set of dimensions.\n  return bestMatch;\n}\n\n/**\n * Calculate the base rem font size.\n *\n * This is how the magic happens. This accepts an optional `screenType` name. If one isn't provided,\n * the currently detected screen type is used. This uses the config option `orientationHandling`,\n * which when set to \"scale\" and the screen is in portrait orientation, will dynamically calculate\n * what the base font size should be, if the width were proportionally scaled down to fit in the portrait space.\n *\n * To use, put the following in your application code:\n * ```\n * import ri from '@enact/ui/resolution';\n *\n * ri.config.orientationHandling = 'scale';\n * ri.init();\n * ```\n *\n * This has no effect if the screen is in landscape, or if `orientationHandling` is unset.\n *\n * @function\n * @memberof ui/resolution\n * @param {String}    type    Screen type to base size the calculation on. If no\n *                            screen type is provided, the current screen type will be used.\n * @returns {String}          The calculated pixel size (with unit suffix. Ex: \"24px\").\n * @public\n */\nfunction calculateFontSize(type) {\n  var scrObj = getScreenTypeObject(type);\n  var shouldScaleFontSize = config.intermediateScreenHandling === 'scale' && (config.matchSmallerScreenType ? workspaceBounds.width > scrObj.width && workspaceBounds.height > scrObj.height : workspaceBounds.width < scrObj.width && workspaceBounds.height < scrObj.height);\n  var size;\n  if (orientation === 'portrait' && config.orientationHandling === 'scale') {\n    size = scrObj.height / scrObj.width * scrObj.pxPerRem;\n  } else {\n    size = scrObj.pxPerRem;\n    if (orientation === 'landscape' && shouldScaleFontSize) {\n      size = parseInt(workspaceBounds.height * scrObj.pxPerRem / scrObj.height);\n    }\n  }\n  return size + 'px';\n}\n\n/**\n * @function\n * @memberof ui/resolution\n * @param {String}    size     A valid CSS measurement to be applied as the base document font size.\n * @private\n * @returns {undefined}\n */\nfunction updateBaseFontSize(size) {\n  if (typeof window === 'object') {\n    document.documentElement.style.fontSize = size;\n  }\n}\n\n/**\n * Returns the CSS classes for the given `type`.\n *\n * @function\n * @memberof ui/resolution\n * @param {String}    type    Screen type\n * @returns {String}          CSS class names\n * @public\n */\nfunction getResolutionClasses() {\n  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : screenType;\n  var classes = [];\n  if (orientation) {\n    classes.push('enact-orientation-' + orientation);\n  }\n  if (type) {\n    classes.push('enact-res-' + type.toLowerCase());\n    var scrObj = getScreenTypeObject(type);\n    if (scrObj.aspectRatioName) {\n      classes.push('enact-aspect-ratio-' + scrObj.aspectRatioName.toLowerCase());\n    }\n  }\n  return classes.join(' ');\n}\n\n/**\n * Returns the ratio of pixels per rem for the given `type` to the pixels per rem for the base type.\n *\n * @function\n * @memberof ui/resolution\n * @param  {String}    type    Screen type\n *\n * @returns {Number}           ratio\n */\nfunction getRiRatio() {\n  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : screenType;\n  if (type && baseScreen) {\n    var ratio = getUnitToPixelFactors(type) / getUnitToPixelFactors(baseScreen.name);\n    if (type === screenType) {\n      // cache this if it's for our current screen type.\n      riRatio = ratio;\n    }\n    return ratio;\n  }\n  return 1;\n}\n\n/**\n * Returns the pixels per rem for the given `type`.\n *\n * @memberof ui/resolution\n * @param {String}    type    Screen type\n *\n * @returns {Number}          pixels per rem\n */\nfunction getUnitToPixelFactors() {\n  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : screenType;\n  if (type) {\n    return getScreenTypeObject(type).pxPerRem;\n  }\n  return 1;\n}\n\n/**\n * Calculates the aspect ratio of the specified screen type.\n *\n * If no screen type is provided, the current screen type is used.\n *\n * @function\n * @memberof ui/resolution\n * @param {String}    type    Screen type whose aspect ratio will be calculated. If no screen\n *                            type is provided, the current screen type is used.\n * @returns {Number}          The calculated screen ratio (e.g., `1.333`, `1.777`, `2.333`, etc.)\n * @public\n */\nfunction getAspectRatio(type) {\n  var scrObj = getScreenTypeObject(type);\n  if (scrObj.width && scrObj.height) {\n    return scrObj.width / scrObj.height;\n  }\n  return 1;\n}\n\n/**\n * Returns the name of the aspect ratio for a specified screen type, or for the default\n * screen type if none is provided.\n *\n * @function\n * @memberof ui/resolution\n * @param {String}    type    Screen type whose aspect ratio name will be returned. If no\n *                            screen type is provided, the current screen type will be used.\n * @returns {String}          The name of the screen type's aspect ratio\n * @public\n */\nfunction getAspectRatioName(type) {\n  var scrObj = getScreenTypeObject(type);\n  return scrObj.aspectRatioName || 'standard';\n}\n\n/**\n * Takes a provided pixel value and performs a scaling operation based on the current\n * screen type.\n *\n * @function\n * @memberof ui/resolution\n * @param {Number}    px    The quantity of standard-resolution pixels to scale to the\n *                          current screen resolution.\n * @returns {Number}        The scaled value based on the current screen scaling factor\n * @public\n */\nfunction scale(px) {\n  return (riRatio || getRiRatio()) * px;\n}\n\n/**\n * Convert to various unit formats.\n *\n * Useful for converting pixels to a resolution-independent\n * measurement method, like \"rem\". Other units are available if defined in the\n * {@link ui/resolution.unitToPixelFactors} object.\n *\n * Example:\n * ```\n * import ri from '@enact/ui/resolution';\n *\n * // Do calculations and get back the desired CSS unit.\n * var frameWidth = 250,\n *     frameWithMarginInches = ri.unit( 10 + frameWidth + 10, 'in' ), // '2.8125in' == frameWithMarginInches\n *     frameWithMarginRems = ri.unit( 10 + frameWidth + 10, 'rem' ); // '22.5rem' == frameWithMarginRems\n * ```\n *\n * @function\n * @memberof ui/resolution\n * @param {String|Number}     pixels    The pixels or math to convert to the unit (\"px\" suffix in String\n *                                       format is permitted. ex: `'20px'`)\n * @param {String}            toUnit    The name of the unit to convert to.\n *\n * @returns {String|undefined}          Resulting conversion in CSS safe format, in case of malformed input, `undefined`\n * @public\n */\nfunction unit(pixels, toUnit) {\n  if (!toUnit || !unitToPixelFactors[toUnit]) return;\n  if (typeof pixels === 'string' && pixels.substr(-2) === 'px') pixels = parseInt(pixels.substr(0, pixels.length - 2));\n  if (typeof pixels !== 'number') return;\n  return pixels / unitToPixelFactors[toUnit] + '' + toUnit;\n}\n\n/**\n * Shorthand for when you know you need to scale some pixel value and have it converted to \"rem\" for\n * proper scaling.\n *\n * This runs {@link ui/resolution.scale} and {@link ui/resolution.unit} together.\n *\n * @function\n * @memberof ui/resolution\n * @param {Number}    pixels    The quantity of standard-resolution pixels to scale to rems\n *\n * @returns {String|undefined}  Resulting conversion or, in case of malformed input, `undefined`\n * @public\n */\nvar scaleToRem = function scaleToRem(pixels) {\n  return unit(scale(pixels), 'rem');\n};\n\n/**\n * The default configurable options for {@link ui/resolution.selectSrc}. Additional resolutions\n * may be added.\n *\n * @typedef {Object} selectSrcOptions\n * @memberof ui/resolution\n * @property {String}    [hd]    HD / 720p Resolution image asset source URI/URL\n * @property {String}    [fhd]   FHD / 1080p Resolution image asset source URI/URL\n * @property {String}    [uhd]   UHD / 4K Resolution image asset source URI/URL\n */\n\n/**\n * Selects the ideal image asset from a set of assets, based on various screen\n * resolutions: HD (720p), FHD (1080p), UHD (4k).\n *\n * When a `src` argument is provided, `selectSrc()` will choose the best image with\n * respect to the current screen resolution. `src` may be either the traditional\n * string, which will pass straight through, or a hash/object of screen types and\n * their asset sources (keys:screen and values:src). The image sources will be used\n * when the screen resolution is less than or equal to the provided screen types.\n *\n * Example:\n * ```\n * // Take advantage of the multi-res mode\n * import {Image} from '@enact/ui/Image';\n *\n * const src = {\n *     'hd': 'http://lorempixel.com/64/64/city/1/',\n *     'fhd': 'http://lorempixel.com/128/128/city/1/',\n *     'uhd': 'http://lorempixel.com/256/256/city/1/'\n * };\n * ...\n * <Image src={src} ... />\n * ...\n * ```\n *\n * @function\n * @memberof ui/resolution\n * @param {String|ui/resolution.selectSrcSrcOptions} src       A string containing a single image\n *                                                             source or a key/value hash/object\n *                                                             containing keys representing screen\n *                                                             types (`'hd'`, `'fhd'`, `'uhd'`,\n *                                                             etc.) and values containing the asset\n *                                                             source for that target screen\n *                                                             resolution.\n *\n * @returns {String}                                           The chosen source, given the string\n *                                                             or hash provided\n * @public\n */\nexports.scaleToRem = scaleToRem;\nfunction selectSrc(src) {\n  if (typeof src != 'string' && src) {\n    var newSrc = src.fhd || src.uhd || src.hd;\n    var types = screenTypes;\n\n    // loop through resolutions\n    for (var i = types.length - 1; i >= 0; i--) {\n      var t = types[i].name;\n      if (screenType === t && src[t]) newSrc = src[t];\n    }\n    src = newSrc;\n  }\n  return src;\n}\n\n/**\n * This will need to be re-run any time the screen size changes, so all the values can be re-cached.\n *\n * @function\n * @memberof ui/resolution\n * @param {Object}    args    A hash of options. The key `measurementNode` is used to as the node,\n *                            typically the root element, to measure and use as the dimensions for\n *                            the `screenType`.\n *\n * @returns {undefined}\n * @public\n */\nfunction init() {\n  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var measurementNode = args.measurementNode;\n  updateWorkspaceBounds(measurementNode);\n  screenType = getScreenType();\n  screenTypeObject = getScreenTypeObject();\n  unitToPixelFactors.rem = getUnitToPixelFactors();\n  riRatio = getRiRatio();\n  updateBaseFontSize(calculateFontSize());\n}\n\n/**\n * The current configuration\n *\n * @type {Object}\n * @memberof ui/resolution\n * @private\n */\nexports.config = config = Object.assign({}, configDefaults);","map":{"version":3,"names":["Object","defineProperty","exports","value","calculateFontSize","config","defineScreenTypes","getAspectRatio","getAspectRatioName","getResolutionClasses","getScreenType","getScreenTypeObject","init","scale","scaleToRem","selectSrc","unit","unitToPixelFactors","baseScreen","orientation","riRatio","screenType","workspaceBounds","width","window","innerWidth","height","innerHeight","screenTypes","name","pxPerRem","aspectRatioName","base","screenTypeObject","configDefaults","intermediateScreenHandling","matchSmallerScreenType","orientationHandling","updateWorkspaceBounds","measurementNode","clientHeight","clientWidth","type","filter","elem","types","i","length","rez","bestMatch","swap","_i","scrObj","shouldScaleFontSize","size","parseInt","updateBaseFontSize","document","documentElement","style","fontSize","arguments","undefined","classes","push","toLowerCase","join","getRiRatio","ratio","getUnitToPixelFactors","px","pixels","toUnit","substr","src","newSrc","fhd","uhd","hd","t","args","rem","assign"],"sources":["/Users/gitchan/Projects/gitchan-yonsei/2024-enact-template/node_modules/@enact/ui/resolution/resolution.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calculateFontSize = calculateFontSize;\nexports.config = void 0;\nexports.defineScreenTypes = defineScreenTypes;\nexports.getAspectRatio = getAspectRatio;\nexports.getAspectRatioName = getAspectRatioName;\nexports.getResolutionClasses = getResolutionClasses;\nexports.getScreenType = getScreenType;\nexports.getScreenTypeObject = getScreenTypeObject;\nexports.init = init;\nexports.scale = scale;\nexports.scaleToRem = void 0;\nexports.selectSrc = selectSrc;\nexports.unit = unit;\nexports.unitToPixelFactors = void 0;\nvar baseScreen,\n  orientation,\n  riRatio,\n  screenType,\n  workspaceBounds = {\n    width: typeof window === 'object' ? window.innerWidth : 1920,\n    height: typeof window === 'object' ? window.innerHeight : 1080\n  },\n  screenTypes = [{\n    name: 'standard',\n    pxPerRem: 16,\n    width: workspaceBounds.width,\n    height: workspaceBounds.height,\n    aspectRatioName: 'standard',\n    base: true\n  }],\n  // Assign one sane type in case defineScreenTypes is never run.\n  screenTypeObject,\n  config;\n\n/**\n * Object that stores all of the pixel conversion factors to each keyed unit.\n *\n * @type {Object}\n * @memberof ui/resolution\n * @public\n */\nexports.config = config;\nvar unitToPixelFactors = {\n  'rem': 12,\n  'in': 96\n};\nexports.unitToPixelFactors = unitToPixelFactors;\nvar configDefaults = {\n  intermediateScreenHandling: 'normal',\n  matchSmallerScreenType: false,\n  orientationHandling: 'normal'\n};\n\n/**\n * Update the common measured boundary object.\n *\n * This object is used as \"what size screen are we looking at\". Providing no arguments has no\n * effect and updates nothing.\n *\n * @function\n * @memberOf ui/resolution\n * @param {Node}    measurementNode    A standard DOM node or the `window` node.\n *\n * @returns {undefined}\n * @private\n */\nvar updateWorkspaceBounds = function updateWorkspaceBounds(measurementNode) {\n  if (measurementNode && (measurementNode.clientHeight || measurementNode.clientWidth)) {\n    workspaceBounds = {\n      height: measurementNode.clientHeight,\n      width: measurementNode.clientWidth\n    };\n  } else if (measurementNode && (measurementNode.innerHeight || measurementNode.innerWidth)) {\n    // A backup for if measurementNode is actually `window` and not a normal node\n    workspaceBounds = {\n      height: measurementNode.innerHeight,\n      width: measurementNode.innerWidth\n    };\n  }\n};\n\n/**\n * Fetch the screenType object\n *\n * @function\n * @memberof ui/resolution\n * @param  {String}    type    The key string for the screen type object. If falsy, the current\n *                             screenType is used\n *\n * @returns {Object}           screenTypeObject\n * @private\n */\nfunction getScreenTypeObject(type) {\n  type = type || screenType;\n  if (screenTypeObject && screenTypeObject.name === type) {\n    return screenTypeObject;\n  }\n  return screenTypes.filter(function (elem) {\n    return type === elem.name;\n  })[0];\n}\n\n/**\n * Sets up screen resolution scaling capabilities by defining an array of all the screens\n * being used.\n *\n * These should be listed in order from smallest to largest, according to\n * width.\n *\n * The `name`, `pxPerRem`, `width`, and `aspectRatioName` properties are required for\n * each screen type in the array. Setting `base: true` on a screen type marks it as the\n * default resolution, upon which everything else will be based.\n *\n * Executing this method also initializes the rest of the resolution-independence code.\n *\n * Example:\n * ```\n * import ri from 'enact/ui/resolution';\n *\n * ri.defineScreenTypes([\n * \t{name: 'vga',     pxPerRem: 8,  width: 640,  height: 480,  aspectRatioName: 'standard'},\n * \t{name: 'xga',     pxPerRem: 16, width: 1024, height: 768,  aspectRatioName: 'standard'},\n * \t{name: 'hd',      pxPerRem: 16, width: 1280, height: 720,  aspectRatioName: 'hdtv'},\n * \t{name: 'fhd',     pxPerRem: 24, width: 1920, height: 1080, aspectRatioName: 'hdtv', base: true},\n * \t{name: 'uw-uxga', pxPerRem: 24, width: 2560, height: 1080, aspectRatioName: 'cinema'},\n * \t{name: 'uhd',     pxPerRem: 48, width: 3840, height: 2160, aspectRatioName: 'hdtv'}\n * ]);\n * ```\n *\n * @function\n * @memberof ui/resolution\n * @param {Object[]}    types    An array of objects containing screen configuration data, as in the\n *                            preceding example.\n * @returns {undefined}\n * @public\n */\nfunction defineScreenTypes(types) {\n  if (types) screenTypes = types;\n  for (var i = 0; i < screenTypes.length; i++) {\n    if (screenTypes[i]['base']) baseScreen = screenTypes[i];\n  }\n  init();\n}\n\n/**\n * Fetches the name of the screen type that best matches the current screen size.\n *\n * The best match is defined as the screen type that is the closest to the screen resolution without\n * going over. (\"The Price is Right\" style.)\n *\n * @function\n * @memberof ui/resolution\n * @param {Object}    rez    Optional measurement scheme. Must include `height` and `width` properties.\n * @returns {String}         Screen type (e.g., `'fhd'`, `'uhd'`, etc.)\n * @public\n */\nfunction getScreenType(rez) {\n  rez = rez || workspaceBounds;\n  var types = screenTypes;\n  var bestMatch = config.matchSmallerScreenType ? types[0].name : types[types.length - 1].name; // Blindly set the first screen type, in case no matches are found later.\n\n  orientation = 'landscape';\n  if (rez.height > rez.width) {\n    orientation = 'portrait';\n    var swap = rez.width;\n    rez.width = rez.height;\n    rez.height = swap;\n  }\n  if (config.matchSmallerScreenType) {\n    // Loop through resolutions, first->last, smallest->largest\n    for (var i = 0; i <= types.length - 1; i++) {\n      // Does this screenType definition fit inside the current resolution? If so, save it as the current best match.\n      if (rez.height >= types[i].height && rez.width >= types[i].width) {\n        bestMatch = types[i].name;\n      }\n    }\n  } else {\n    // Loop through resolutions, last->first, largest->smallest\n    for (var _i = types.length - 1; _i >= 0; _i--) {\n      // Does the current resolution fit inside this screenType definition? If so, save it as the current best match.\n      if (rez.height <= types[_i].height && rez.width <= types[_i].width) {\n        bestMatch = types[_i].name;\n      }\n    }\n  }\n\n  // Return the name of the closest fitting set of dimensions.\n  return bestMatch;\n}\n\n/**\n * Calculate the base rem font size.\n *\n * This is how the magic happens. This accepts an optional `screenType` name. If one isn't provided,\n * the currently detected screen type is used. This uses the config option `orientationHandling`,\n * which when set to \"scale\" and the screen is in portrait orientation, will dynamically calculate\n * what the base font size should be, if the width were proportionally scaled down to fit in the portrait space.\n *\n * To use, put the following in your application code:\n * ```\n * import ri from '@enact/ui/resolution';\n *\n * ri.config.orientationHandling = 'scale';\n * ri.init();\n * ```\n *\n * This has no effect if the screen is in landscape, or if `orientationHandling` is unset.\n *\n * @function\n * @memberof ui/resolution\n * @param {String}    type    Screen type to base size the calculation on. If no\n *                            screen type is provided, the current screen type will be used.\n * @returns {String}          The calculated pixel size (with unit suffix. Ex: \"24px\").\n * @public\n */\nfunction calculateFontSize(type) {\n  var scrObj = getScreenTypeObject(type);\n  var shouldScaleFontSize = config.intermediateScreenHandling === 'scale' && (config.matchSmallerScreenType ? workspaceBounds.width > scrObj.width && workspaceBounds.height > scrObj.height : workspaceBounds.width < scrObj.width && workspaceBounds.height < scrObj.height);\n  var size;\n  if (orientation === 'portrait' && config.orientationHandling === 'scale') {\n    size = scrObj.height / scrObj.width * scrObj.pxPerRem;\n  } else {\n    size = scrObj.pxPerRem;\n    if (orientation === 'landscape' && shouldScaleFontSize) {\n      size = parseInt(workspaceBounds.height * scrObj.pxPerRem / scrObj.height);\n    }\n  }\n  return size + 'px';\n}\n\n/**\n * @function\n * @memberof ui/resolution\n * @param {String}    size     A valid CSS measurement to be applied as the base document font size.\n * @private\n * @returns {undefined}\n */\nfunction updateBaseFontSize(size) {\n  if (typeof window === 'object') {\n    document.documentElement.style.fontSize = size;\n  }\n}\n\n/**\n * Returns the CSS classes for the given `type`.\n *\n * @function\n * @memberof ui/resolution\n * @param {String}    type    Screen type\n * @returns {String}          CSS class names\n * @public\n */\nfunction getResolutionClasses() {\n  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : screenType;\n  var classes = [];\n  if (orientation) {\n    classes.push('enact-orientation-' + orientation);\n  }\n  if (type) {\n    classes.push('enact-res-' + type.toLowerCase());\n    var scrObj = getScreenTypeObject(type);\n    if (scrObj.aspectRatioName) {\n      classes.push('enact-aspect-ratio-' + scrObj.aspectRatioName.toLowerCase());\n    }\n  }\n  return classes.join(' ');\n}\n\n/**\n * Returns the ratio of pixels per rem for the given `type` to the pixels per rem for the base type.\n *\n * @function\n * @memberof ui/resolution\n * @param  {String}    type    Screen type\n *\n * @returns {Number}           ratio\n */\nfunction getRiRatio() {\n  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : screenType;\n  if (type && baseScreen) {\n    var ratio = getUnitToPixelFactors(type) / getUnitToPixelFactors(baseScreen.name);\n    if (type === screenType) {\n      // cache this if it's for our current screen type.\n      riRatio = ratio;\n    }\n    return ratio;\n  }\n  return 1;\n}\n\n/**\n * Returns the pixels per rem for the given `type`.\n *\n * @memberof ui/resolution\n * @param {String}    type    Screen type\n *\n * @returns {Number}          pixels per rem\n */\nfunction getUnitToPixelFactors() {\n  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : screenType;\n  if (type) {\n    return getScreenTypeObject(type).pxPerRem;\n  }\n  return 1;\n}\n\n/**\n * Calculates the aspect ratio of the specified screen type.\n *\n * If no screen type is provided, the current screen type is used.\n *\n * @function\n * @memberof ui/resolution\n * @param {String}    type    Screen type whose aspect ratio will be calculated. If no screen\n *                            type is provided, the current screen type is used.\n * @returns {Number}          The calculated screen ratio (e.g., `1.333`, `1.777`, `2.333`, etc.)\n * @public\n */\nfunction getAspectRatio(type) {\n  var scrObj = getScreenTypeObject(type);\n  if (scrObj.width && scrObj.height) {\n    return scrObj.width / scrObj.height;\n  }\n  return 1;\n}\n\n/**\n * Returns the name of the aspect ratio for a specified screen type, or for the default\n * screen type if none is provided.\n *\n * @function\n * @memberof ui/resolution\n * @param {String}    type    Screen type whose aspect ratio name will be returned. If no\n *                            screen type is provided, the current screen type will be used.\n * @returns {String}          The name of the screen type's aspect ratio\n * @public\n */\nfunction getAspectRatioName(type) {\n  var scrObj = getScreenTypeObject(type);\n  return scrObj.aspectRatioName || 'standard';\n}\n\n/**\n * Takes a provided pixel value and performs a scaling operation based on the current\n * screen type.\n *\n * @function\n * @memberof ui/resolution\n * @param {Number}    px    The quantity of standard-resolution pixels to scale to the\n *                          current screen resolution.\n * @returns {Number}        The scaled value based on the current screen scaling factor\n * @public\n */\nfunction scale(px) {\n  return (riRatio || getRiRatio()) * px;\n}\n\n/**\n * Convert to various unit formats.\n *\n * Useful for converting pixels to a resolution-independent\n * measurement method, like \"rem\". Other units are available if defined in the\n * {@link ui/resolution.unitToPixelFactors} object.\n *\n * Example:\n * ```\n * import ri from '@enact/ui/resolution';\n *\n * // Do calculations and get back the desired CSS unit.\n * var frameWidth = 250,\n *     frameWithMarginInches = ri.unit( 10 + frameWidth + 10, 'in' ), // '2.8125in' == frameWithMarginInches\n *     frameWithMarginRems = ri.unit( 10 + frameWidth + 10, 'rem' ); // '22.5rem' == frameWithMarginRems\n * ```\n *\n * @function\n * @memberof ui/resolution\n * @param {String|Number}     pixels    The pixels or math to convert to the unit (\"px\" suffix in String\n *                                       format is permitted. ex: `'20px'`)\n * @param {String}            toUnit    The name of the unit to convert to.\n *\n * @returns {String|undefined}          Resulting conversion in CSS safe format, in case of malformed input, `undefined`\n * @public\n */\nfunction unit(pixels, toUnit) {\n  if (!toUnit || !unitToPixelFactors[toUnit]) return;\n  if (typeof pixels === 'string' && pixels.substr(-2) === 'px') pixels = parseInt(pixels.substr(0, pixels.length - 2));\n  if (typeof pixels !== 'number') return;\n  return pixels / unitToPixelFactors[toUnit] + '' + toUnit;\n}\n\n/**\n * Shorthand for when you know you need to scale some pixel value and have it converted to \"rem\" for\n * proper scaling.\n *\n * This runs {@link ui/resolution.scale} and {@link ui/resolution.unit} together.\n *\n * @function\n * @memberof ui/resolution\n * @param {Number}    pixels    The quantity of standard-resolution pixels to scale to rems\n *\n * @returns {String|undefined}  Resulting conversion or, in case of malformed input, `undefined`\n * @public\n */\nvar scaleToRem = function scaleToRem(pixels) {\n  return unit(scale(pixels), 'rem');\n};\n\n/**\n * The default configurable options for {@link ui/resolution.selectSrc}. Additional resolutions\n * may be added.\n *\n * @typedef {Object} selectSrcOptions\n * @memberof ui/resolution\n * @property {String}    [hd]    HD / 720p Resolution image asset source URI/URL\n * @property {String}    [fhd]   FHD / 1080p Resolution image asset source URI/URL\n * @property {String}    [uhd]   UHD / 4K Resolution image asset source URI/URL\n */\n\n/**\n * Selects the ideal image asset from a set of assets, based on various screen\n * resolutions: HD (720p), FHD (1080p), UHD (4k).\n *\n * When a `src` argument is provided, `selectSrc()` will choose the best image with\n * respect to the current screen resolution. `src` may be either the traditional\n * string, which will pass straight through, or a hash/object of screen types and\n * their asset sources (keys:screen and values:src). The image sources will be used\n * when the screen resolution is less than or equal to the provided screen types.\n *\n * Example:\n * ```\n * // Take advantage of the multi-res mode\n * import {Image} from '@enact/ui/Image';\n *\n * const src = {\n *     'hd': 'http://lorempixel.com/64/64/city/1/',\n *     'fhd': 'http://lorempixel.com/128/128/city/1/',\n *     'uhd': 'http://lorempixel.com/256/256/city/1/'\n * };\n * ...\n * <Image src={src} ... />\n * ...\n * ```\n *\n * @function\n * @memberof ui/resolution\n * @param {String|ui/resolution.selectSrcSrcOptions} src       A string containing a single image\n *                                                             source or a key/value hash/object\n *                                                             containing keys representing screen\n *                                                             types (`'hd'`, `'fhd'`, `'uhd'`,\n *                                                             etc.) and values containing the asset\n *                                                             source for that target screen\n *                                                             resolution.\n *\n * @returns {String}                                           The chosen source, given the string\n *                                                             or hash provided\n * @public\n */\nexports.scaleToRem = scaleToRem;\nfunction selectSrc(src) {\n  if (typeof src != 'string' && src) {\n    var newSrc = src.fhd || src.uhd || src.hd;\n    var types = screenTypes;\n\n    // loop through resolutions\n    for (var i = types.length - 1; i >= 0; i--) {\n      var t = types[i].name;\n      if (screenType === t && src[t]) newSrc = src[t];\n    }\n    src = newSrc;\n  }\n  return src;\n}\n\n/**\n * This will need to be re-run any time the screen size changes, so all the values can be re-cached.\n *\n * @function\n * @memberof ui/resolution\n * @param {Object}    args    A hash of options. The key `measurementNode` is used to as the node,\n *                            typically the root element, to measure and use as the dimensions for\n *                            the `screenType`.\n *\n * @returns {undefined}\n * @public\n */\nfunction init() {\n  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var measurementNode = args.measurementNode;\n  updateWorkspaceBounds(measurementNode);\n  screenType = getScreenType();\n  screenTypeObject = getScreenTypeObject();\n  unitToPixelFactors.rem = getUnitToPixelFactors();\n  riRatio = getRiRatio();\n  updateBaseFontSize(calculateFontSize());\n}\n\n/**\n * The current configuration\n *\n * @type {Object}\n * @memberof ui/resolution\n * @private\n */\nexports.config = config = Object.assign({}, configDefaults);"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}