{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toSegments = exports.stringifyRoutes = exports.resolve = exports.propTypes = exports.RouteContext = void 0;\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\nvar _react = require(\"react\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nvar RouteContext = /*#__PURE__*/(0, _react.createContext)(null);\nexports.RouteContext = RouteContext;\nvar toSegments = function toSegments(path) {\n  return Array.isArray(path) ? path : (path || '').split('/').filter(Boolean);\n};\nexports.toSegments = toSegments;\nvar getPaths = function getPaths(routes, base) {\n  var result = [];\n  Object.keys(routes).filter(function (s) {\n    return s[0] !== '$';\n  }).forEach(function (p) {\n    var path = base + '/' + p;\n    result.push(path);\n    result = result.concat(getPaths(routes[p], path));\n  });\n  return result;\n};\nvar stringifyRoutes = function stringifyRoutes(routes) {\n  var pad = '\\n\\t';\n  var paths = getPaths(routes, '');\n  return pad + paths.join(pad);\n};\n\n// resolves path relative to base\nexports.stringifyRoutes = stringifyRoutes;\nvar resolve = function resolve() {\n  var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';\n  var path = arguments.length > 1 ? arguments[1] : undefined;\n  // We could resolve to base but we want to consider this an error condition\n  if (!path) return;\n\n  // convert a base array to a string for simpler normalization\n  if (base instanceof Array) base = base.join('/');\n\n  // normalize base to have a leading slash\n  if (!base.startsWith('/')) base = '/' + base;\n\n  // if path has a leading slash, it's an absolute path so return it\n  if (path.startsWith('/')) return path;\n\n  // if path isn't absolute and doesn't begin with ., it's relative to the base\n  if (!path.startsWith('.')) return base + '/' + path;\n\n  // convert to arrays remove empty paths from base\n  base = base.split('/').filter(Boolean);\n  path = path.split('/');\n  while (path.length > 0) {\n    var p = path.shift();\n    if (!p || p === '.') {\n      // if we have an empty path or a current directory path, continue\n      continue;\n    } else if (p === '..') {\n      // if we're down the root and we encounter a parent path, return\n      if (base.length === 0) return;\n      // otherwise, remove a level from base\n      base.pop();\n    } else {\n      // put back the current element so it can be included in the output path\n      path.unshift(p);\n      break;\n    }\n  }\n\n  // finally rebuild the path including the segment we just shifted\n  return \"/\".concat(base.concat(path).join('/'));\n};\nexports.resolve = resolve;\nvar propTypes = {\n  path: _propTypes[\"default\"].oneOfType([_propTypes[\"default\"].arrayOf(_propTypes[\"default\"].string),\n  // array of path segments\n  _propTypes[\"default\"].string // URI-style path\n  ])\n};\n\nexports.propTypes = propTypes;","map":{"version":3,"names":["Object","defineProperty","exports","value","toSegments","stringifyRoutes","resolve","propTypes","RouteContext","_propTypes","_interopRequireDefault","require","_react","obj","__esModule","createContext","path","Array","isArray","split","filter","Boolean","getPaths","routes","base","result","keys","s","forEach","p","push","concat","pad","paths","join","arguments","length","undefined","startsWith","shift","pop","unshift","oneOfType","arrayOf","string"],"sources":["/Users/gitchan/Projects/gitchan-yonsei/2024-enact-template/node_modules/@enact/ui/Routable/util.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toSegments = exports.stringifyRoutes = exports.resolve = exports.propTypes = exports.RouteContext = void 0;\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\nvar _react = require(\"react\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar RouteContext = /*#__PURE__*/(0, _react.createContext)(null);\nexports.RouteContext = RouteContext;\nvar toSegments = function toSegments(path) {\n  return Array.isArray(path) ? path : (path || '').split('/').filter(Boolean);\n};\nexports.toSegments = toSegments;\nvar getPaths = function getPaths(routes, base) {\n  var result = [];\n  Object.keys(routes).filter(function (s) {\n    return s[0] !== '$';\n  }).forEach(function (p) {\n    var path = base + '/' + p;\n    result.push(path);\n    result = result.concat(getPaths(routes[p], path));\n  });\n  return result;\n};\nvar stringifyRoutes = function stringifyRoutes(routes) {\n  var pad = '\\n\\t';\n  var paths = getPaths(routes, '');\n  return pad + paths.join(pad);\n};\n\n// resolves path relative to base\nexports.stringifyRoutes = stringifyRoutes;\nvar resolve = function resolve() {\n  var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/';\n  var path = arguments.length > 1 ? arguments[1] : undefined;\n  // We could resolve to base but we want to consider this an error condition\n  if (!path) return;\n\n  // convert a base array to a string for simpler normalization\n  if (base instanceof Array) base = base.join('/');\n\n  // normalize base to have a leading slash\n  if (!base.startsWith('/')) base = '/' + base;\n\n  // if path has a leading slash, it's an absolute path so return it\n  if (path.startsWith('/')) return path;\n\n  // if path isn't absolute and doesn't begin with ., it's relative to the base\n  if (!path.startsWith('.')) return base + '/' + path;\n\n  // convert to arrays remove empty paths from base\n  base = base.split('/').filter(Boolean);\n  path = path.split('/');\n  while (path.length > 0) {\n    var p = path.shift();\n    if (!p || p === '.') {\n      // if we have an empty path or a current directory path, continue\n      continue;\n    } else if (p === '..') {\n      // if we're down the root and we encounter a parent path, return\n      if (base.length === 0) return;\n      // otherwise, remove a level from base\n      base.pop();\n    } else {\n      // put back the current element so it can be included in the output path\n      path.unshift(p);\n      break;\n    }\n  }\n\n  // finally rebuild the path including the segment we just shifted\n  return \"/\".concat(base.concat(path).join('/'));\n};\nexports.resolve = resolve;\nvar propTypes = {\n  path: _propTypes[\"default\"].oneOfType([_propTypes[\"default\"].arrayOf(_propTypes[\"default\"].string),\n  // array of path segments\n  _propTypes[\"default\"].string // URI-style path\n  ])\n};\nexports.propTypes = propTypes;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}